// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: media-delivery/videocontent.proto

package api

import (
	_ "github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2/options"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	_ "google.golang.org/protobuf/types/known/emptypb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type DeliveryStatus int32

const (
	DeliveryStatus_DeliveryStatusUnknown    DeliveryStatus = 0
	DeliveryStatus_DeliveryStatusFailed     DeliveryStatus = 1
	DeliveryStatus_DeliveryStatusInProgress DeliveryStatus = 2
	DeliveryStatus_DeliveryStatusDelivered  DeliveryStatus = 3
)

// Enum value maps for DeliveryStatus.
var (
	DeliveryStatus_name = map[int32]string{
		0: "DeliveryStatusUnknown",
		1: "DeliveryStatusFailed",
		2: "DeliveryStatusInProgress",
		3: "DeliveryStatusDelivered",
	}
	DeliveryStatus_value = map[string]int32{
		"DeliveryStatusUnknown":    0,
		"DeliveryStatusFailed":     1,
		"DeliveryStatusInProgress": 2,
		"DeliveryStatusDelivered":  3,
	}
)

func (x DeliveryStatus) Enum() *DeliveryStatus {
	p := new(DeliveryStatus)
	*p = x
	return p
}

func (x DeliveryStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DeliveryStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_media_delivery_videocontent_proto_enumTypes[0].Descriptor()
}

func (DeliveryStatus) Type() protoreflect.EnumType {
	return &file_media_delivery_videocontent_proto_enumTypes[0]
}

func (x DeliveryStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DeliveryStatus.Descriptor instead.
func (DeliveryStatus) EnumDescriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{0}
}

type Status int32

const (
	Status_StatusUnknown    Status = 0
	Status_NewStatus        Status = 1
	Status_InProgressStatus Status = 2
	Status_CompletedStatus  Status = 3
	Status_FailedStatus     Status = 4
)

// Enum value maps for Status.
var (
	Status_name = map[int32]string{
		0: "StatusUnknown",
		1: "NewStatus",
		2: "InProgressStatus",
		3: "CompletedStatus",
		4: "FailedStatus",
	}
	Status_value = map[string]int32{
		"StatusUnknown":    0,
		"NewStatus":        1,
		"InProgressStatus": 2,
		"CompletedStatus":  3,
		"FailedStatus":     4,
	}
)

func (x Status) Enum() *Status {
	p := new(Status)
	*p = x
	return p
}

func (x Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Status) Descriptor() protoreflect.EnumDescriptor {
	return file_media_delivery_videocontent_proto_enumTypes[1].Descriptor()
}

func (Status) Type() protoreflect.EnumType {
	return &file_media_delivery_videocontent_proto_enumTypes[1]
}

func (x Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Status.Descriptor instead.
func (Status) EnumDescriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{1}
}

type TVShowDeliveryStep int32

const (
	// Неизвестный статус доставки
	TVShowDeliveryStep_TVShowDeliveryStepUnknown TVShowDeliveryStep = 0
	// Генерация запроса к трекеру
	TVShowDeliveryStep_GenerateSearchQuery TVShowDeliveryStep = 1
	// Поиск раздач сезона сериала/фильма
	TVShowDeliveryStep_SearchTorrents TVShowDeliveryStep = 2
	// Ожидание выбора раздачи пользователем
	TVShowDeliveryStep_WaitingUserChoseTorrent TVShowDeliveryStep = 3
	// Получение магнет ссылки
	TVShowDeliveryStep_GetMagnetLink TVShowDeliveryStep = 4
	// Добавление раздачи для скачивания торрент клиентом
	TVShowDeliveryStep_AddTorrentToTorrentClient TVShowDeliveryStep = 5
	// Получение информации о файлах раздачи
	TVShowDeliveryStep_PrepareFileMatches TVShowDeliveryStep = 6
	// Ожидание подтверждения пользователем соответствий выбора файлов
	TVShowDeliveryStep_WaitingChoseFileMatches TVShowDeliveryStep = 7
	// Ожидание завершения окончания скачивания раздачи
	TVShowDeliveryStep_WaitingTorrentDownloadComplete TVShowDeliveryStep = 8
	// Формирование каталогов и иерархии файлов
	TVShowDeliveryStep_CreateVideoContentCatalogs TVShowDeliveryStep = 9
	// Определение необходимости конвертации файлов
	TVShowDeliveryStep_DeterminingNeedConvertFiles TVShowDeliveryStep = 10
	// Запуск конвертирования файлов
	TVShowDeliveryStep_StartMergeVideoFiles TVShowDeliveryStep = 11
	// Ожидание завершения конвертации файлов
	TVShowDeliveryStep_WaitingMergeVideoFiles TVShowDeliveryStep = 12
	// Копирование файлов из раздачи в каталог медиасервера (точнее создание симлинков)
	TVShowDeliveryStep_CreateHardLinkCopy TVShowDeliveryStep = 13
	// GetCatalogsSize получение размеров каталогов сериала
	TVShowDeliveryStep_GetCatalogsSize TVShowDeliveryStep = 15
	// Установка методаных серий сезона сериала/фильма в медиасервере
	TVShowDeliveryStep_SetMediaMetaData TVShowDeliveryStep = 16
	// Отправка уведомления в telegramm о успешной доставки
	TVShowDeliveryStep_SendDeliveryNotification TVShowDeliveryStep = 17
	// Ожидание когда появится информация о файлах в раздаче
	TVShowDeliveryStep_WaitingTorrentFiles TVShowDeliveryStep = 18
	// получение информации о эпизодах и каталоге сезона
	TVShowDeliveryStep_GetEpisodesData TVShowDeliveryStep = 19
)

// Enum value maps for TVShowDeliveryStep.
var (
	TVShowDeliveryStep_name = map[int32]string{
		0:  "TVShowDeliveryStepUnknown",
		1:  "GenerateSearchQuery",
		2:  "SearchTorrents",
		3:  "WaitingUserChoseTorrent",
		4:  "GetMagnetLink",
		5:  "AddTorrentToTorrentClient",
		6:  "PrepareFileMatches",
		7:  "WaitingChoseFileMatches",
		8:  "WaitingTorrentDownloadComplete",
		9:  "CreateVideoContentCatalogs",
		10: "DeterminingNeedConvertFiles",
		11: "StartMergeVideoFiles",
		12: "WaitingMergeVideoFiles",
		13: "CreateHardLinkCopy",
		15: "GetCatalogsSize",
		16: "SetMediaMetaData",
		17: "SendDeliveryNotification",
		18: "WaitingTorrentFiles",
		19: "GetEpisodesData",
	}
	TVShowDeliveryStep_value = map[string]int32{
		"TVShowDeliveryStepUnknown":      0,
		"GenerateSearchQuery":            1,
		"SearchTorrents":                 2,
		"WaitingUserChoseTorrent":        3,
		"GetMagnetLink":                  4,
		"AddTorrentToTorrentClient":      5,
		"PrepareFileMatches":             6,
		"WaitingChoseFileMatches":        7,
		"WaitingTorrentDownloadComplete": 8,
		"CreateVideoContentCatalogs":     9,
		"DeterminingNeedConvertFiles":    10,
		"StartMergeVideoFiles":           11,
		"WaitingMergeVideoFiles":         12,
		"CreateHardLinkCopy":             13,
		"GetCatalogsSize":                15,
		"SetMediaMetaData":               16,
		"SendDeliveryNotification":       17,
		"WaitingTorrentFiles":            18,
		"GetEpisodesData":                19,
	}
)

func (x TVShowDeliveryStep) Enum() *TVShowDeliveryStep {
	p := new(TVShowDeliveryStep)
	*p = x
	return p
}

func (x TVShowDeliveryStep) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TVShowDeliveryStep) Descriptor() protoreflect.EnumDescriptor {
	return file_media_delivery_videocontent_proto_enumTypes[2].Descriptor()
}

func (TVShowDeliveryStep) Type() protoreflect.EnumType {
	return &file_media_delivery_videocontent_proto_enumTypes[2]
}

func (x TVShowDeliveryStep) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TVShowDeliveryStep.Descriptor instead.
func (TVShowDeliveryStep) EnumDescriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{2}
}

type Track_TrackType int32

const (
	Track_TRACK_TYPE_UNKNOWN  Track_TrackType = 0
	Track_TRACK_TYPE_VIDEO    Track_TrackType = 1
	Track_TRACK_TYPE_AUDIO    Track_TrackType = 2
	Track_TRACK_TYPE_SUBTITLE Track_TrackType = 3
)

// Enum value maps for Track_TrackType.
var (
	Track_TrackType_name = map[int32]string{
		0: "TRACK_TYPE_UNKNOWN",
		1: "TRACK_TYPE_VIDEO",
		2: "TRACK_TYPE_AUDIO",
		3: "TRACK_TYPE_SUBTITLE",
	}
	Track_TrackType_value = map[string]int32{
		"TRACK_TYPE_UNKNOWN":  0,
		"TRACK_TYPE_VIDEO":    1,
		"TRACK_TYPE_AUDIO":    2,
		"TRACK_TYPE_SUBTITLE": 3,
	}
)

func (x Track_TrackType) Enum() *Track_TrackType {
	p := new(Track_TrackType)
	*p = x
	return p
}

func (x Track_TrackType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Track_TrackType) Descriptor() protoreflect.EnumDescriptor {
	return file_media_delivery_videocontent_proto_enumTypes[3].Descriptor()
}

func (Track_TrackType) Type() protoreflect.EnumType {
	return &file_media_delivery_videocontent_proto_enumTypes[3]
}

func (x Track_TrackType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Track_TrackType.Descriptor instead.
func (Track_TrackType) EnumDescriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{5, 0}
}

type TorrentDownloadStatus_TorrentState int32

const (
	TorrentDownloadStatus_TORRENT_STATE_UNKNOWN     TorrentDownloadStatus_TorrentState = 0
	TorrentDownloadStatus_TORRENT_STATE_ERROR       TorrentDownloadStatus_TorrentState = 1
	TorrentDownloadStatus_TORRENT_STATE_UPLOADING   TorrentDownloadStatus_TorrentState = 2
	TorrentDownloadStatus_TORRENT_STATE_DOWNLOADING TorrentDownloadStatus_TorrentState = 3
	TorrentDownloadStatus_TORRENT_STATE_STOPPED     TorrentDownloadStatus_TorrentState = 4
	TorrentDownloadStatus_TORRENT_STATE_QUEUED      TorrentDownloadStatus_TorrentState = 5
)

// Enum value maps for TorrentDownloadStatus_TorrentState.
var (
	TorrentDownloadStatus_TorrentState_name = map[int32]string{
		0: "TORRENT_STATE_UNKNOWN",
		1: "TORRENT_STATE_ERROR",
		2: "TORRENT_STATE_UPLOADING",
		3: "TORRENT_STATE_DOWNLOADING",
		4: "TORRENT_STATE_STOPPED",
		5: "TORRENT_STATE_QUEUED",
	}
	TorrentDownloadStatus_TorrentState_value = map[string]int32{
		"TORRENT_STATE_UNKNOWN":     0,
		"TORRENT_STATE_ERROR":       1,
		"TORRENT_STATE_UPLOADING":   2,
		"TORRENT_STATE_DOWNLOADING": 3,
		"TORRENT_STATE_STOPPED":     4,
		"TORRENT_STATE_QUEUED":      5,
	}
)

func (x TorrentDownloadStatus_TorrentState) Enum() *TorrentDownloadStatus_TorrentState {
	p := new(TorrentDownloadStatus_TorrentState)
	*p = x
	return p
}

func (x TorrentDownloadStatus_TorrentState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TorrentDownloadStatus_TorrentState) Descriptor() protoreflect.EnumDescriptor {
	return file_media_delivery_videocontent_proto_enumTypes[4].Descriptor()
}

func (TorrentDownloadStatus_TorrentState) Type() protoreflect.EnumType {
	return &file_media_delivery_videocontent_proto_enumTypes[4]
}

func (x TorrentDownloadStatus_TorrentState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TorrentDownloadStatus_TorrentState.Descriptor instead.
func (TorrentDownloadStatus_TorrentState) EnumDescriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{8, 0}
}

type TVShowDeliveryError_ErrorType int32

const (
	TVShowDeliveryError_TVShowDeliveryError_Unknown TVShowDeliveryError_ErrorType = 0
	// Торрент трекер не доступен
	TVShowDeliveryError_TorrentSiteForbidden TVShowDeliveryError_ErrorType = 1
	// Файлы на медиасервере уже существуют
	TVShowDeliveryError_FilesAlreadyExist TVShowDeliveryError_ErrorType = 2
)

// Enum value maps for TVShowDeliveryError_ErrorType.
var (
	TVShowDeliveryError_ErrorType_name = map[int32]string{
		0: "TVShowDeliveryError_Unknown",
		1: "TorrentSiteForbidden",
		2: "FilesAlreadyExist",
	}
	TVShowDeliveryError_ErrorType_value = map[string]int32{
		"TVShowDeliveryError_Unknown": 0,
		"TorrentSiteForbidden":        1,
		"FilesAlreadyExist":           2,
	}
)

func (x TVShowDeliveryError_ErrorType) Enum() *TVShowDeliveryError_ErrorType {
	p := new(TVShowDeliveryError_ErrorType)
	*p = x
	return p
}

func (x TVShowDeliveryError_ErrorType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TVShowDeliveryError_ErrorType) Descriptor() protoreflect.EnumDescriptor {
	return file_media_delivery_videocontent_proto_enumTypes[5].Descriptor()
}

func (TVShowDeliveryError_ErrorType) Type() protoreflect.EnumType {
	return &file_media_delivery_videocontent_proto_enumTypes[5]
}

func (x TVShowDeliveryError_ErrorType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TVShowDeliveryError_ErrorType.Descriptor instead.
func (TVShowDeliveryError_ErrorType) EnumDescriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{14, 0}
}

type TVShowID struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            uint64                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	SeasonNumber  uint32                 `protobuf:"varint,2,opt,name=season_number,json=seasonNumber,proto3" json:"season_number,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TVShowID) Reset() {
	*x = TVShowID{}
	mi := &file_media_delivery_videocontent_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TVShowID) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TVShowID) ProtoMessage() {}

func (x *TVShowID) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_videocontent_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TVShowID.ProtoReflect.Descriptor instead.
func (*TVShowID) Descriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{0}
}

func (x *TVShowID) GetId() uint64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *TVShowID) GetSeasonNumber() uint32 {
	if x != nil {
		return x.SeasonNumber
	}
	return 0
}

type ContentID struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	MovieId       *uint64                `protobuf:"varint,1,opt,name=movie_id,json=movieId,proto3,oneof" json:"movie_id,omitempty"`
	TvShow        *TVShowID              `protobuf:"bytes,2,opt,name=tv_show,json=tvShow,proto3,oneof" json:"tv_show,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ContentID) Reset() {
	*x = ContentID{}
	mi := &file_media_delivery_videocontent_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ContentID) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContentID) ProtoMessage() {}

func (x *ContentID) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_videocontent_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContentID.ProtoReflect.Descriptor instead.
func (*ContentID) Descriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{1}
}

func (x *ContentID) GetMovieId() uint64 {
	if x != nil && x.MovieId != nil {
		return *x.MovieId
	}
	return 0
}

func (x *ContentID) GetTvShow() *TVShowID {
	if x != nil {
		return x.TvShow
	}
	return nil
}

type VideoContent struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Id             string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	CreatedAt      *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	DeliveryStatus DeliveryStatus         `protobuf:"varint,3,opt,name=delivery_status,json=deliveryStatus,proto3,enum=mediadelivery.DeliveryStatus" json:"delivery_status,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *VideoContent) Reset() {
	*x = VideoContent{}
	mi := &file_media_delivery_videocontent_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VideoContent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VideoContent) ProtoMessage() {}

func (x *VideoContent) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_videocontent_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VideoContent.ProtoReflect.Descriptor instead.
func (*VideoContent) Descriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{2}
}

func (x *VideoContent) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *VideoContent) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *VideoContent) GetDeliveryStatus() DeliveryStatus {
	if x != nil {
		return x.DeliveryStatus
	}
	return DeliveryStatus_DeliveryStatusUnknown
}

type TorrentSearch struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Title         string                 `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Href          string                 `protobuf:"bytes,2,opt,name=href,proto3" json:"href,omitempty"`
	Category      string                 `protobuf:"bytes,8,opt,name=category,proto3" json:"category,omitempty"`
	Size          string                 `protobuf:"bytes,3,opt,name=size,proto3" json:"size,omitempty"`
	Seeds         int64                  `protobuf:"varint,4,opt,name=seeds,proto3" json:"seeds,omitempty"`
	Leeches       int64                  `protobuf:"varint,5,opt,name=leeches,proto3" json:"leeches,omitempty"`
	Downloads     int64                  `protobuf:"varint,6,opt,name=downloads,proto3" json:"downloads,omitempty"`
	AddedDate     string                 `protobuf:"bytes,7,opt,name=added_date,json=addedDate,proto3" json:"added_date,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TorrentSearch) Reset() {
	*x = TorrentSearch{}
	mi := &file_media_delivery_videocontent_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TorrentSearch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TorrentSearch) ProtoMessage() {}

func (x *TorrentSearch) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_videocontent_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TorrentSearch.ProtoReflect.Descriptor instead.
func (*TorrentSearch) Descriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{3}
}

func (x *TorrentSearch) GetTitle() string {
	if x != nil {
		return x.Title
	}
	return ""
}

func (x *TorrentSearch) GetHref() string {
	if x != nil {
		return x.Href
	}
	return ""
}

func (x *TorrentSearch) GetCategory() string {
	if x != nil {
		return x.Category
	}
	return ""
}

func (x *TorrentSearch) GetSize() string {
	if x != nil {
		return x.Size
	}
	return ""
}

func (x *TorrentSearch) GetSeeds() int64 {
	if x != nil {
		return x.Seeds
	}
	return 0
}

func (x *TorrentSearch) GetLeeches() int64 {
	if x != nil {
		return x.Leeches
	}
	return 0
}

func (x *TorrentSearch) GetDownloads() int64 {
	if x != nil {
		return x.Downloads
	}
	return 0
}

func (x *TorrentSearch) GetAddedDate() string {
	if x != nil {
		return x.AddedDate
	}
	return ""
}

type EpisodeInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SeasonNumber  uint32                 `protobuf:"varint,1,opt,name=season_number,json=seasonNumber,proto3" json:"season_number,omitempty"`
	EpisodeNumber uint32                 `protobuf:"varint,2,opt,name=episode_number,json=episodeNumber,proto3" json:"episode_number,omitempty"`
	FullPath      string                 `protobuf:"bytes,3,opt,name=full_path,json=fullPath,proto3" json:"full_path,omitempty"`
	RelativePath  string                 `protobuf:"bytes,4,opt,name=relative_path,json=relativePath,proto3" json:"relative_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EpisodeInfo) Reset() {
	*x = EpisodeInfo{}
	mi := &file_media_delivery_videocontent_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EpisodeInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EpisodeInfo) ProtoMessage() {}

func (x *EpisodeInfo) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_videocontent_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EpisodeInfo.ProtoReflect.Descriptor instead.
func (*EpisodeInfo) Descriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{4}
}

func (x *EpisodeInfo) GetSeasonNumber() uint32 {
	if x != nil {
		return x.SeasonNumber
	}
	return 0
}

func (x *EpisodeInfo) GetEpisodeNumber() uint32 {
	if x != nil {
		return x.EpisodeNumber
	}
	return 0
}

func (x *EpisodeInfo) GetFullPath() string {
	if x != nil {
		return x.FullPath
	}
	return ""
}

func (x *EpisodeInfo) GetRelativePath() string {
	if x != nil {
		return x.RelativePath
	}
	return ""
}

type Track struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RelativePath  string                 `protobuf:"bytes,1,opt,name=relative_path,json=relativePath,proto3" json:"relative_path,omitempty"`
	FullPath      string                 `protobuf:"bytes,2,opt,name=full_path,json=fullPath,proto3" json:"full_path,omitempty"`
	Name          *string                `protobuf:"bytes,3,opt,name=name,proto3,oneof" json:"name,omitempty"`
	Language      *string                `protobuf:"bytes,4,opt,name=language,proto3,oneof" json:"language,omitempty"`
	Type          Track_TrackType        `protobuf:"varint,5,opt,name=type,proto3,enum=mediadelivery.Track_TrackType" json:"type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Track) Reset() {
	*x = Track{}
	mi := &file_media_delivery_videocontent_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Track) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Track) ProtoMessage() {}

func (x *Track) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_videocontent_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Track.ProtoReflect.Descriptor instead.
func (*Track) Descriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{5}
}

func (x *Track) GetRelativePath() string {
	if x != nil {
		return x.RelativePath
	}
	return ""
}

func (x *Track) GetFullPath() string {
	if x != nil {
		return x.FullPath
	}
	return ""
}

func (x *Track) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *Track) GetLanguage() string {
	if x != nil && x.Language != nil {
		return *x.Language
	}
	return ""
}

func (x *Track) GetType() Track_TrackType {
	if x != nil {
		return x.Type
	}
	return Track_TRACK_TYPE_UNKNOWN
}

type ContentMatch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Инфа о сезоне
	Episode *EpisodeInfo `protobuf:"bytes,1,opt,name=episode,proto3" json:"episode,omitempty"`
	// Видеодорожка
	Video *Track `protobuf:"bytes,2,opt,name=video,proto3" json:"video,omitempty"`
	// Аудиодорожки
	AudioTracks []*Track `protobuf:"bytes,3,rep,name=audio_tracks,json=audioTracks,proto3" json:"audio_tracks,omitempty"`
	// Субтитры
	Subtitles     []*Track `protobuf:"bytes,4,rep,name=subtitles,proto3" json:"subtitles,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ContentMatch) Reset() {
	*x = ContentMatch{}
	mi := &file_media_delivery_videocontent_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ContentMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContentMatch) ProtoMessage() {}

func (x *ContentMatch) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_videocontent_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContentMatch.ProtoReflect.Descriptor instead.
func (*ContentMatch) Descriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{6}
}

func (x *ContentMatch) GetEpisode() *EpisodeInfo {
	if x != nil {
		return x.Episode
	}
	return nil
}

func (x *ContentMatch) GetVideo() *Track {
	if x != nil {
		return x.Video
	}
	return nil
}

func (x *ContentMatch) GetAudioTracks() []*Track {
	if x != nil {
		return x.AudioTracks
	}
	return nil
}

func (x *ContentMatch) GetSubtitles() []*Track {
	if x != nil {
		return x.Subtitles
	}
	return nil
}

type ContentMatches struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Matches []*ContentMatch        `protobuf:"bytes,1,rep,name=matches,proto3" json:"matches,omitempty"`
	// Нераспредленные треки
	Unallocated []*Track `protobuf:"bytes,2,rep,name=unallocated,proto3" json:"unallocated,omitempty"`
	// Опции
	Options       *ContentMatches_Options `protobuf:"bytes,3,opt,name=options,proto3" json:"options,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ContentMatches) Reset() {
	*x = ContentMatches{}
	mi := &file_media_delivery_videocontent_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ContentMatches) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContentMatches) ProtoMessage() {}

func (x *ContentMatches) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_videocontent_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContentMatches.ProtoReflect.Descriptor instead.
func (*ContentMatches) Descriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{7}
}

func (x *ContentMatches) GetMatches() []*ContentMatch {
	if x != nil {
		return x.Matches
	}
	return nil
}

func (x *ContentMatches) GetUnallocated() []*Track {
	if x != nil {
		return x.Unallocated
	}
	return nil
}

func (x *ContentMatches) GetOptions() *ContentMatches_Options {
	if x != nil {
		return x.Options
	}
	return nil
}

type TorrentDownloadStatus struct {
	state         protoimpl.MessageState             `protogen:"open.v1"`
	State         TorrentDownloadStatus_TorrentState `protobuf:"varint,1,opt,name=state,proto3,enum=mediadelivery.TorrentDownloadStatus_TorrentState" json:"state,omitempty"`
	Progress      float32                            `protobuf:"fixed32,2,opt,name=progress,proto3" json:"progress,omitempty"`
	IsComplete    bool                               `protobuf:"varint,3,opt,name=is_complete,json=isComplete,proto3" json:"is_complete,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TorrentDownloadStatus) Reset() {
	*x = TorrentDownloadStatus{}
	mi := &file_media_delivery_videocontent_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TorrentDownloadStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TorrentDownloadStatus) ProtoMessage() {}

func (x *TorrentDownloadStatus) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_videocontent_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TorrentDownloadStatus.ProtoReflect.Descriptor instead.
func (*TorrentDownloadStatus) Descriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{8}
}

func (x *TorrentDownloadStatus) GetState() TorrentDownloadStatus_TorrentState {
	if x != nil {
		return x.State
	}
	return TorrentDownloadStatus_TORRENT_STATE_UNKNOWN
}

func (x *TorrentDownloadStatus) GetProgress() float32 {
	if x != nil {
		return x.Progress
	}
	return 0
}

func (x *TorrentDownloadStatus) GetIsComplete() bool {
	if x != nil {
		return x.IsComplete
	}
	return false
}

type MergeVideoStatus struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Progress      float32                `protobuf:"fixed32,1,opt,name=progress,proto3" json:"progress,omitempty"`
	IsComplete    bool                   `protobuf:"varint,2,opt,name=is_complete,json=isComplete,proto3" json:"is_complete,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MergeVideoStatus) Reset() {
	*x = MergeVideoStatus{}
	mi := &file_media_delivery_videocontent_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MergeVideoStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MergeVideoStatus) ProtoMessage() {}

func (x *MergeVideoStatus) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_videocontent_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MergeVideoStatus.ProtoReflect.Descriptor instead.
func (*MergeVideoStatus) Descriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{9}
}

func (x *MergeVideoStatus) GetProgress() float32 {
	if x != nil {
		return x.Progress
	}
	return 0
}

func (x *MergeVideoStatus) GetIsComplete() bool {
	if x != nil {
		return x.IsComplete
	}
	return false
}

type TVShowCatalogPath struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Путь до каталога сериала
	TvShowPath string `protobuf:"bytes,1,opt,name=tv_show_path,json=tvShowPath,proto3" json:"tv_show_path,omitempty"`
	// Путь до каталога сезона (относительно каталога сериала)
	SeasonPath    string `protobuf:"bytes,2,opt,name=season_path,json=seasonPath,proto3" json:"season_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TVShowCatalogPath) Reset() {
	*x = TVShowCatalogPath{}
	mi := &file_media_delivery_videocontent_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TVShowCatalogPath) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TVShowCatalogPath) ProtoMessage() {}

func (x *TVShowCatalogPath) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_videocontent_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TVShowCatalogPath.ProtoReflect.Descriptor instead.
func (*TVShowCatalogPath) Descriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{10}
}

func (x *TVShowCatalogPath) GetTvShowPath() string {
	if x != nil {
		return x.TvShowPath
	}
	return ""
}

func (x *TVShowCatalogPath) GetSeasonPath() string {
	if x != nil {
		return x.SeasonPath
	}
	return ""
}

type TVShowCatalog struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Путь до раздачи сезона сериала
	TorrentPath string `protobuf:"bytes,1,opt,name=torrent_path,json=torrentPath,proto3" json:"torrent_path,omitempty"`
	// Размер файлов раздачи сезона сериала
	TorrentSizePretty string `protobuf:"bytes,2,opt,name=torrent_size_pretty,json=torrentSizePretty,proto3" json:"torrent_size_pretty,omitempty"`
	// Путь до сезона сериала на медиасервере
	MediaServerPath *TVShowCatalogPath `protobuf:"bytes,3,opt,name=media_server_path,json=mediaServerPath,proto3" json:"media_server_path,omitempty"`
	// Размер файлов раздачи сезона сериала (байты)
	MediaServerSizePretty string `protobuf:"bytes,4,opt,name=media_server_size_pretty,json=mediaServerSizePretty,proto3" json:"media_server_size_pretty,omitempty"`
	// Файлы скопированы с раздачи или созданы ссылочная связь
	// True - файлы скопированы
	// False - файлы созданы через линки
	IsCopyFilesInMediaServer bool `protobuf:"varint,5,opt,name=is_copy_files_in_media_server,json=isCopyFilesInMediaServer,proto3" json:"is_copy_files_in_media_server,omitempty"`
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *TVShowCatalog) Reset() {
	*x = TVShowCatalog{}
	mi := &file_media_delivery_videocontent_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TVShowCatalog) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TVShowCatalog) ProtoMessage() {}

func (x *TVShowCatalog) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_videocontent_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TVShowCatalog.ProtoReflect.Descriptor instead.
func (*TVShowCatalog) Descriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{11}
}

func (x *TVShowCatalog) GetTorrentPath() string {
	if x != nil {
		return x.TorrentPath
	}
	return ""
}

func (x *TVShowCatalog) GetTorrentSizePretty() string {
	if x != nil {
		return x.TorrentSizePretty
	}
	return ""
}

func (x *TVShowCatalog) GetMediaServerPath() *TVShowCatalogPath {
	if x != nil {
		return x.MediaServerPath
	}
	return nil
}

func (x *TVShowCatalog) GetMediaServerSizePretty() string {
	if x != nil {
		return x.MediaServerSizePretty
	}
	return ""
}

func (x *TVShowCatalog) GetIsCopyFilesInMediaServer() bool {
	if x != nil {
		return x.IsCopyFilesInMediaServer
	}
	return false
}

type Torrent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Ссылка на раздачу
	Href          string `protobuf:"bytes,1,opt,name=href,proto3" json:"href,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Torrent) Reset() {
	*x = Torrent{}
	mi := &file_media_delivery_videocontent_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Torrent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Torrent) ProtoMessage() {}

func (x *Torrent) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_videocontent_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Torrent.ProtoReflect.Descriptor instead.
func (*Torrent) Descriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{12}
}

func (x *Torrent) GetHref() string {
	if x != nil {
		return x.Href
	}
	return ""
}

type TVShowDeliveryData struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Поисковый запрос поиска торрент файла
	SearchQuery *SearchQuery `protobuf:"bytes,1,opt,name=search_query,json=searchQuery,proto3,oneof" json:"search_query,omitempty"`
	// Результат поиска торрент раздач
	TorrentSearch []*TorrentSearch `protobuf:"bytes,2,rep,name=torrent_search,json=torrentSearch,proto3" json:"torrent_search,omitempty"`
	// Результат метча файлов
	ContentMatches *ContentMatches `protobuf:"bytes,3,opt,name=content_matches,json=contentMatches,proto3,oneof" json:"content_matches,omitempty"`
	// статус скачивания раздачи
	TorrentDownloadStatus *TorrentDownloadStatus `protobuf:"bytes,4,opt,name=torrent_download_status,json=torrentDownloadStatus,proto3,oneof" json:"torrent_download_status,omitempty"`
	// статус сшивания файлов
	MergeVideoStatus *MergeVideoStatus `protobuf:"bytes,5,opt,name=merge_video_status,json=mergeVideoStatus,proto3,oneof" json:"merge_video_status,omitempty"`
	// TVShowCatalogInfo информация о каталогах сериала
	TvShowCatalogInfo *TVShowCatalog `protobuf:"bytes,6,opt,name=tv_show_catalog_info,json=tvShowCatalogInfo,proto3,oneof" json:"tv_show_catalog_info,omitempty"`
	// Информация о раздаче
	Torrent       *Torrent `protobuf:"bytes,7,opt,name=torrent,proto3,oneof" json:"torrent,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TVShowDeliveryData) Reset() {
	*x = TVShowDeliveryData{}
	mi := &file_media_delivery_videocontent_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TVShowDeliveryData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TVShowDeliveryData) ProtoMessage() {}

func (x *TVShowDeliveryData) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_videocontent_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TVShowDeliveryData.ProtoReflect.Descriptor instead.
func (*TVShowDeliveryData) Descriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{13}
}

func (x *TVShowDeliveryData) GetSearchQuery() *SearchQuery {
	if x != nil {
		return x.SearchQuery
	}
	return nil
}

func (x *TVShowDeliveryData) GetTorrentSearch() []*TorrentSearch {
	if x != nil {
		return x.TorrentSearch
	}
	return nil
}

func (x *TVShowDeliveryData) GetContentMatches() *ContentMatches {
	if x != nil {
		return x.ContentMatches
	}
	return nil
}

func (x *TVShowDeliveryData) GetTorrentDownloadStatus() *TorrentDownloadStatus {
	if x != nil {
		return x.TorrentDownloadStatus
	}
	return nil
}

func (x *TVShowDeliveryData) GetMergeVideoStatus() *MergeVideoStatus {
	if x != nil {
		return x.MergeVideoStatus
	}
	return nil
}

func (x *TVShowDeliveryData) GetTvShowCatalogInfo() *TVShowCatalog {
	if x != nil {
		return x.TvShowCatalogInfo
	}
	return nil
}

func (x *TVShowDeliveryData) GetTorrent() *Torrent {
	if x != nil {
		return x.Torrent
	}
	return nil
}

type TVShowDeliveryError struct {
	state         protoimpl.MessageState        `protogen:"open.v1"`
	RawError      string                        `protobuf:"bytes,1,opt,name=raw_error,json=rawError,proto3" json:"raw_error,omitempty"`
	ErrorType     TVShowDeliveryError_ErrorType `protobuf:"varint,2,opt,name=error_type,json=errorType,proto3,enum=mediadelivery.TVShowDeliveryError_ErrorType" json:"error_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TVShowDeliveryError) Reset() {
	*x = TVShowDeliveryError{}
	mi := &file_media_delivery_videocontent_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TVShowDeliveryError) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TVShowDeliveryError) ProtoMessage() {}

func (x *TVShowDeliveryError) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_videocontent_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TVShowDeliveryError.ProtoReflect.Descriptor instead.
func (*TVShowDeliveryError) Descriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{14}
}

func (x *TVShowDeliveryError) GetRawError() string {
	if x != nil {
		return x.RawError
	}
	return ""
}

func (x *TVShowDeliveryError) GetErrorType() TVShowDeliveryError_ErrorType {
	if x != nil {
		return x.ErrorType
	}
	return TVShowDeliveryError_TVShowDeliveryError_Unknown
}

type SearchQuery struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Query         string                 `protobuf:"bytes,1,opt,name=Query,proto3" json:"Query,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SearchQuery) Reset() {
	*x = SearchQuery{}
	mi := &file_media_delivery_videocontent_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SearchQuery) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SearchQuery) ProtoMessage() {}

func (x *SearchQuery) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_videocontent_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SearchQuery.ProtoReflect.Descriptor instead.
func (*SearchQuery) Descriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{15}
}

func (x *SearchQuery) GetQuery() string {
	if x != nil {
		return x.Query
	}
	return ""
}

type TVShowDeliveryState struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Data          *TVShowDeliveryData    `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Step          TVShowDeliveryStep     `protobuf:"varint,2,opt,name=step,proto3,enum=mediadelivery.TVShowDeliveryStep" json:"step,omitempty"`
	Status        Status                 `protobuf:"varint,3,opt,name=status,proto3,enum=mediadelivery.Status" json:"status,omitempty"`
	Error         *TVShowDeliveryError   `protobuf:"bytes,4,opt,name=error,proto3,oneof" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TVShowDeliveryState) Reset() {
	*x = TVShowDeliveryState{}
	mi := &file_media_delivery_videocontent_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TVShowDeliveryState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TVShowDeliveryState) ProtoMessage() {}

func (x *TVShowDeliveryState) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_videocontent_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TVShowDeliveryState.ProtoReflect.Descriptor instead.
func (*TVShowDeliveryState) Descriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{16}
}

func (x *TVShowDeliveryState) GetData() *TVShowDeliveryData {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *TVShowDeliveryState) GetStep() TVShowDeliveryStep {
	if x != nil {
		return x.Step
	}
	return TVShowDeliveryStep_TVShowDeliveryStepUnknown
}

func (x *TVShowDeliveryState) GetStatus() Status {
	if x != nil {
		return x.Status
	}
	return Status_StatusUnknown
}

func (x *TVShowDeliveryState) GetError() *TVShowDeliveryError {
	if x != nil {
		return x.Error
	}
	return nil
}

type CreateVideoContentRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ContentId     *ContentID             `protobuf:"bytes,1,opt,name=content_id,json=contentId,proto3" json:"content_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateVideoContentRequest) Reset() {
	*x = CreateVideoContentRequest{}
	mi := &file_media_delivery_videocontent_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateVideoContentRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateVideoContentRequest) ProtoMessage() {}

func (x *CreateVideoContentRequest) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_videocontent_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateVideoContentRequest.ProtoReflect.Descriptor instead.
func (*CreateVideoContentRequest) Descriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{17}
}

func (x *CreateVideoContentRequest) GetContentId() *ContentID {
	if x != nil {
		return x.ContentId
	}
	return nil
}

type CreateVideoContentResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Result        *VideoContent          `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateVideoContentResponse) Reset() {
	*x = CreateVideoContentResponse{}
	mi := &file_media_delivery_videocontent_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateVideoContentResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateVideoContentResponse) ProtoMessage() {}

func (x *CreateVideoContentResponse) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_videocontent_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateVideoContentResponse.ProtoReflect.Descriptor instead.
func (*CreateVideoContentResponse) Descriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{18}
}

func (x *CreateVideoContentResponse) GetResult() *VideoContent {
	if x != nil {
		return x.Result
	}
	return nil
}

type GetVideoContentRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ContentId     *ContentID             `protobuf:"bytes,1,opt,name=content_id,json=contentId,proto3" json:"content_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetVideoContentRequest) Reset() {
	*x = GetVideoContentRequest{}
	mi := &file_media_delivery_videocontent_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetVideoContentRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetVideoContentRequest) ProtoMessage() {}

func (x *GetVideoContentRequest) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_videocontent_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetVideoContentRequest.ProtoReflect.Descriptor instead.
func (*GetVideoContentRequest) Descriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{19}
}

func (x *GetVideoContentRequest) GetContentId() *ContentID {
	if x != nil {
		return x.ContentId
	}
	return nil
}

type GetVideoContentResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Items         []*VideoContent        `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetVideoContentResponse) Reset() {
	*x = GetVideoContentResponse{}
	mi := &file_media_delivery_videocontent_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetVideoContentResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetVideoContentResponse) ProtoMessage() {}

func (x *GetVideoContentResponse) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_videocontent_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetVideoContentResponse.ProtoReflect.Descriptor instead.
func (*GetVideoContentResponse) Descriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{20}
}

func (x *GetVideoContentResponse) GetItems() []*VideoContent {
	if x != nil {
		return x.Items
	}
	return nil
}

type GetTVShowDeliveryDataRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ContentId     *ContentID             `protobuf:"bytes,1,opt,name=content_id,json=contentId,proto3" json:"content_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetTVShowDeliveryDataRequest) Reset() {
	*x = GetTVShowDeliveryDataRequest{}
	mi := &file_media_delivery_videocontent_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetTVShowDeliveryDataRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetTVShowDeliveryDataRequest) ProtoMessage() {}

func (x *GetTVShowDeliveryDataRequest) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_videocontent_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetTVShowDeliveryDataRequest.ProtoReflect.Descriptor instead.
func (*GetTVShowDeliveryDataRequest) Descriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{21}
}

func (x *GetTVShowDeliveryDataRequest) GetContentId() *ContentID {
	if x != nil {
		return x.ContentId
	}
	return nil
}

type GetTVShowDeliveryDataResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Result        *TVShowDeliveryState   `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetTVShowDeliveryDataResponse) Reset() {
	*x = GetTVShowDeliveryDataResponse{}
	mi := &file_media_delivery_videocontent_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetTVShowDeliveryDataResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetTVShowDeliveryDataResponse) ProtoMessage() {}

func (x *GetTVShowDeliveryDataResponse) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_videocontent_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetTVShowDeliveryDataResponse.ProtoReflect.Descriptor instead.
func (*GetTVShowDeliveryDataResponse) Descriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{22}
}

func (x *GetTVShowDeliveryDataResponse) GetResult() *TVShowDeliveryState {
	if x != nil {
		return x.Result
	}
	return nil
}

type ChoseTorrentOptionsRequest struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	ContentId *ContentID             `protobuf:"bytes,1,opt,name=content_id,json=contentId,proto3" json:"content_id,omitempty"`
	// Пользователь выбрал конкретный торрента файл
	Href *string `protobuf:"bytes,2,opt,name=href,proto3,oneof" json:"href,omitempty"`
	// Пользователь поменял поисковый запрос
	NewSearchQuery *string `protobuf:"bytes,3,opt,name=new_search_query,json=newSearchQuery,proto3,oneof" json:"new_search_query,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ChoseTorrentOptionsRequest) Reset() {
	*x = ChoseTorrentOptionsRequest{}
	mi := &file_media_delivery_videocontent_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChoseTorrentOptionsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChoseTorrentOptionsRequest) ProtoMessage() {}

func (x *ChoseTorrentOptionsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_videocontent_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChoseTorrentOptionsRequest.ProtoReflect.Descriptor instead.
func (*ChoseTorrentOptionsRequest) Descriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{23}
}

func (x *ChoseTorrentOptionsRequest) GetContentId() *ContentID {
	if x != nil {
		return x.ContentId
	}
	return nil
}

func (x *ChoseTorrentOptionsRequest) GetHref() string {
	if x != nil && x.Href != nil {
		return *x.Href
	}
	return ""
}

func (x *ChoseTorrentOptionsRequest) GetNewSearchQuery() string {
	if x != nil && x.NewSearchQuery != nil {
		return *x.NewSearchQuery
	}
	return ""
}

type ChoseTorrentOptionsResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Result        *TVShowDeliveryState   `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChoseTorrentOptionsResponse) Reset() {
	*x = ChoseTorrentOptionsResponse{}
	mi := &file_media_delivery_videocontent_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChoseTorrentOptionsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChoseTorrentOptionsResponse) ProtoMessage() {}

func (x *ChoseTorrentOptionsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_videocontent_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChoseTorrentOptionsResponse.ProtoReflect.Descriptor instead.
func (*ChoseTorrentOptionsResponse) Descriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{24}
}

func (x *ChoseTorrentOptionsResponse) GetResult() *TVShowDeliveryState {
	if x != nil {
		return x.Result
	}
	return nil
}

type ChoseFileMatchesOptionsRequest struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	ContentId *ContentID             `protobuf:"bytes,1,opt,name=content_id,json=contentId,proto3" json:"content_id,omitempty"`
	// Пользователь подтверждает сметченные файлы
	Approve bool `protobuf:"varint,2,opt,name=approve,proto3" json:"approve,omitempty"`
	// Метч контента, если захотели изменить
	ContentMatches *ContentMatches `protobuf:"bytes,3,opt,name=content_matches,json=contentMatches,proto3,oneof" json:"content_matches,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ChoseFileMatchesOptionsRequest) Reset() {
	*x = ChoseFileMatchesOptionsRequest{}
	mi := &file_media_delivery_videocontent_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChoseFileMatchesOptionsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChoseFileMatchesOptionsRequest) ProtoMessage() {}

func (x *ChoseFileMatchesOptionsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_videocontent_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChoseFileMatchesOptionsRequest.ProtoReflect.Descriptor instead.
func (*ChoseFileMatchesOptionsRequest) Descriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{25}
}

func (x *ChoseFileMatchesOptionsRequest) GetContentId() *ContentID {
	if x != nil {
		return x.ContentId
	}
	return nil
}

func (x *ChoseFileMatchesOptionsRequest) GetApprove() bool {
	if x != nil {
		return x.Approve
	}
	return false
}

func (x *ChoseFileMatchesOptionsRequest) GetContentMatches() *ContentMatches {
	if x != nil {
		return x.ContentMatches
	}
	return nil
}

type ChoseFileMatchesOptionsResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Result        *TVShowDeliveryState   `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChoseFileMatchesOptionsResponse) Reset() {
	*x = ChoseFileMatchesOptionsResponse{}
	mi := &file_media_delivery_videocontent_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChoseFileMatchesOptionsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChoseFileMatchesOptionsResponse) ProtoMessage() {}

func (x *ChoseFileMatchesOptionsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_videocontent_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChoseFileMatchesOptionsResponse.ProtoReflect.Descriptor instead.
func (*ChoseFileMatchesOptionsResponse) Descriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{26}
}

func (x *ChoseFileMatchesOptionsResponse) GetResult() *TVShowDeliveryState {
	if x != nil {
		return x.Result
	}
	return nil
}

type ContentMatches_Options struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Оставлять оригинальные аудиодорожки (если они есть)
	KeepOriginalAudio bool `protobuf:"varint,1,opt,name=keep_original_audio,json=keepOriginalAudio,proto3" json:"keep_original_audio,omitempty"`
	// Оставлять оригинальные субтитры (если они есть)
	KeepOriginalSubtitles bool `protobuf:"varint,2,opt,name=keep_original_subtitles,json=keepOriginalSubtitles,proto3" json:"keep_original_subtitles,omitempty"`
	// Дефолтная аудиодорожка
	DefaultAudioTrackName *string `protobuf:"bytes,3,opt,name=default_audio_track_name,json=defaultAudioTrackName,proto3,oneof" json:"default_audio_track_name,omitempty"`
	// Дефолтные субтитры
	DefaultSubtitleTrack *string `protobuf:"bytes,4,opt,name=default_subtitle_track,json=defaultSubtitleTrack,proto3,oneof" json:"default_subtitle_track,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *ContentMatches_Options) Reset() {
	*x = ContentMatches_Options{}
	mi := &file_media_delivery_videocontent_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ContentMatches_Options) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContentMatches_Options) ProtoMessage() {}

func (x *ContentMatches_Options) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_videocontent_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContentMatches_Options.ProtoReflect.Descriptor instead.
func (*ContentMatches_Options) Descriptor() ([]byte, []int) {
	return file_media_delivery_videocontent_proto_rawDescGZIP(), []int{7, 0}
}

func (x *ContentMatches_Options) GetKeepOriginalAudio() bool {
	if x != nil {
		return x.KeepOriginalAudio
	}
	return false
}

func (x *ContentMatches_Options) GetKeepOriginalSubtitles() bool {
	if x != nil {
		return x.KeepOriginalSubtitles
	}
	return false
}

func (x *ContentMatches_Options) GetDefaultAudioTrackName() string {
	if x != nil && x.DefaultAudioTrackName != nil {
		return *x.DefaultAudioTrackName
	}
	return ""
}

func (x *ContentMatches_Options) GetDefaultSubtitleTrack() string {
	if x != nil && x.DefaultSubtitleTrack != nil {
		return *x.DefaultSubtitleTrack
	}
	return ""
}

var File_media_delivery_videocontent_proto protoreflect.FileDescriptor

const file_media_delivery_videocontent_proto_rawDesc = "" +
	"\n" +
	"!media-delivery/videocontent.proto\x12\rmediadelivery\x1a\x1cgoogle/api/annotations.proto\x1a.protoc-gen-openapiv2/options/annotations.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1bgoogle/protobuf/empty.proto\"H\n" +
	"\bTVShowID\x12\x17\n" +
	"\x02id\x18\x01 \x01(\x04B\a\x92A\x04\x9a\x02\x01\x03R\x02id\x12#\n" +
	"\rseason_number\x18\x02 \x01(\rR\fseasonNumber\"\x84\x01\n" +
	"\tContentID\x12'\n" +
	"\bmovie_id\x18\x01 \x01(\x04B\a\x92A\x04\x9a\x02\x01\x03H\x00R\amovieId\x88\x01\x01\x125\n" +
	"\atv_show\x18\x02 \x01(\v2\x17.mediadelivery.TVShowIDH\x01R\x06tvShow\x88\x01\x01B\v\n" +
	"\t_movie_idB\n" +
	"\n" +
	"\b_tv_show\"\xa1\x01\n" +
	"\fVideoContent\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x129\n" +
	"\n" +
	"created_at\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x12F\n" +
	"\x0fdelivery_status\x18\x03 \x01(\x0e2\x1d.mediadelivery.DeliveryStatusR\x0edeliveryStatus\"\xd6\x01\n" +
	"\rTorrentSearch\x12\x14\n" +
	"\x05title\x18\x01 \x01(\tR\x05title\x12\x12\n" +
	"\x04href\x18\x02 \x01(\tR\x04href\x12\x1a\n" +
	"\bcategory\x18\b \x01(\tR\bcategory\x12\x12\n" +
	"\x04size\x18\x03 \x01(\tR\x04size\x12\x14\n" +
	"\x05seeds\x18\x04 \x01(\x03R\x05seeds\x12\x18\n" +
	"\aleeches\x18\x05 \x01(\x03R\aleeches\x12\x1c\n" +
	"\tdownloads\x18\x06 \x01(\x03R\tdownloads\x12\x1d\n" +
	"\n" +
	"added_date\x18\a \x01(\tR\taddedDate\"\x9b\x01\n" +
	"\vEpisodeInfo\x12#\n" +
	"\rseason_number\x18\x01 \x01(\rR\fseasonNumber\x12%\n" +
	"\x0eepisode_number\x18\x02 \x01(\rR\repisodeNumber\x12\x1b\n" +
	"\tfull_path\x18\x03 \x01(\tR\bfullPath\x12#\n" +
	"\rrelative_path\x18\x04 \x01(\tR\frelativePath\"\xb7\x02\n" +
	"\x05Track\x12#\n" +
	"\rrelative_path\x18\x01 \x01(\tR\frelativePath\x12\x1b\n" +
	"\tfull_path\x18\x02 \x01(\tR\bfullPath\x12\x17\n" +
	"\x04name\x18\x03 \x01(\tH\x00R\x04name\x88\x01\x01\x12\x1f\n" +
	"\blanguage\x18\x04 \x01(\tH\x01R\blanguage\x88\x01\x01\x122\n" +
	"\x04type\x18\x05 \x01(\x0e2\x1e.mediadelivery.Track.TrackTypeR\x04type\"h\n" +
	"\tTrackType\x12\x16\n" +
	"\x12TRACK_TYPE_UNKNOWN\x10\x00\x12\x14\n" +
	"\x10TRACK_TYPE_VIDEO\x10\x01\x12\x14\n" +
	"\x10TRACK_TYPE_AUDIO\x10\x02\x12\x17\n" +
	"\x13TRACK_TYPE_SUBTITLE\x10\x03B\a\n" +
	"\x05_nameB\v\n" +
	"\t_language\"\xdd\x01\n" +
	"\fContentMatch\x124\n" +
	"\aepisode\x18\x01 \x01(\v2\x1a.mediadelivery.EpisodeInfoR\aepisode\x12*\n" +
	"\x05video\x18\x02 \x01(\v2\x14.mediadelivery.TrackR\x05video\x127\n" +
	"\faudio_tracks\x18\x03 \x03(\v2\x14.mediadelivery.TrackR\vaudioTracks\x122\n" +
	"\tsubtitles\x18\x04 \x03(\v2\x14.mediadelivery.TrackR\tsubtitles\"\xe5\x03\n" +
	"\x0eContentMatches\x125\n" +
	"\amatches\x18\x01 \x03(\v2\x1b.mediadelivery.ContentMatchR\amatches\x126\n" +
	"\vunallocated\x18\x02 \x03(\v2\x14.mediadelivery.TrackR\vunallocated\x12?\n" +
	"\aoptions\x18\x03 \x01(\v2%.mediadelivery.ContentMatches.OptionsR\aoptions\x1a\xa2\x02\n" +
	"\aOptions\x12.\n" +
	"\x13keep_original_audio\x18\x01 \x01(\bR\x11keepOriginalAudio\x126\n" +
	"\x17keep_original_subtitles\x18\x02 \x01(\bR\x15keepOriginalSubtitles\x12<\n" +
	"\x18default_audio_track_name\x18\x03 \x01(\tH\x00R\x15defaultAudioTrackName\x88\x01\x01\x129\n" +
	"\x16default_subtitle_track\x18\x04 \x01(\tH\x01R\x14defaultSubtitleTrack\x88\x01\x01B\x1b\n" +
	"\x19_default_audio_track_nameB\x19\n" +
	"\x17_default_subtitle_track\"\xd3\x02\n" +
	"\x15TorrentDownloadStatus\x12G\n" +
	"\x05state\x18\x01 \x01(\x0e21.mediadelivery.TorrentDownloadStatus.TorrentStateR\x05state\x12\x1a\n" +
	"\bprogress\x18\x02 \x01(\x02R\bprogress\x12\x1f\n" +
	"\vis_complete\x18\x03 \x01(\bR\n" +
	"isComplete\"\xb3\x01\n" +
	"\fTorrentState\x12\x19\n" +
	"\x15TORRENT_STATE_UNKNOWN\x10\x00\x12\x17\n" +
	"\x13TORRENT_STATE_ERROR\x10\x01\x12\x1b\n" +
	"\x17TORRENT_STATE_UPLOADING\x10\x02\x12\x1d\n" +
	"\x19TORRENT_STATE_DOWNLOADING\x10\x03\x12\x19\n" +
	"\x15TORRENT_STATE_STOPPED\x10\x04\x12\x18\n" +
	"\x14TORRENT_STATE_QUEUED\x10\x05\"O\n" +
	"\x10MergeVideoStatus\x12\x1a\n" +
	"\bprogress\x18\x01 \x01(\x02R\bprogress\x12\x1f\n" +
	"\vis_complete\x18\x02 \x01(\bR\n" +
	"isComplete\"V\n" +
	"\x11TVShowCatalogPath\x12 \n" +
	"\ftv_show_path\x18\x01 \x01(\tR\n" +
	"tvShowPath\x12\x1f\n" +
	"\vseason_path\x18\x02 \x01(\tR\n" +
	"seasonPath\"\xaa\x02\n" +
	"\rTVShowCatalog\x12!\n" +
	"\ftorrent_path\x18\x01 \x01(\tR\vtorrentPath\x12.\n" +
	"\x13torrent_size_pretty\x18\x02 \x01(\tR\x11torrentSizePretty\x12L\n" +
	"\x11media_server_path\x18\x03 \x01(\v2 .mediadelivery.TVShowCatalogPathR\x0fmediaServerPath\x127\n" +
	"\x18media_server_size_pretty\x18\x04 \x01(\tR\x15mediaServerSizePretty\x12?\n" +
	"\x1dis_copy_files_in_media_server\x18\x05 \x01(\bR\x18isCopyFilesInMediaServer\"\x1d\n" +
	"\aTorrent\x12\x12\n" +
	"\x04href\x18\x01 \x01(\tR\x04href\"\xa9\x05\n" +
	"\x12TVShowDeliveryData\x12B\n" +
	"\fsearch_query\x18\x01 \x01(\v2\x1a.mediadelivery.SearchQueryH\x00R\vsearchQuery\x88\x01\x01\x12C\n" +
	"\x0etorrent_search\x18\x02 \x03(\v2\x1c.mediadelivery.TorrentSearchR\rtorrentSearch\x12K\n" +
	"\x0fcontent_matches\x18\x03 \x01(\v2\x1d.mediadelivery.ContentMatchesH\x01R\x0econtentMatches\x88\x01\x01\x12a\n" +
	"\x17torrent_download_status\x18\x04 \x01(\v2$.mediadelivery.TorrentDownloadStatusH\x02R\x15torrentDownloadStatus\x88\x01\x01\x12R\n" +
	"\x12merge_video_status\x18\x05 \x01(\v2\x1f.mediadelivery.MergeVideoStatusH\x03R\x10mergeVideoStatus\x88\x01\x01\x12R\n" +
	"\x14tv_show_catalog_info\x18\x06 \x01(\v2\x1c.mediadelivery.TVShowCatalogH\x04R\x11tvShowCatalogInfo\x88\x01\x01\x125\n" +
	"\atorrent\x18\a \x01(\v2\x16.mediadelivery.TorrentH\x05R\atorrent\x88\x01\x01B\x0f\n" +
	"\r_search_queryB\x12\n" +
	"\x10_content_matchesB\x1a\n" +
	"\x18_torrent_download_statusB\x15\n" +
	"\x13_merge_video_statusB\x17\n" +
	"\x15_tv_show_catalog_infoB\n" +
	"\n" +
	"\b_torrent\"\xde\x01\n" +
	"\x13TVShowDeliveryError\x12\x1b\n" +
	"\traw_error\x18\x01 \x01(\tR\brawError\x12K\n" +
	"\n" +
	"error_type\x18\x02 \x01(\x0e2,.mediadelivery.TVShowDeliveryError.ErrorTypeR\terrorType\"]\n" +
	"\tErrorType\x12\x1f\n" +
	"\x1bTVShowDeliveryError_Unknown\x10\x00\x12\x18\n" +
	"\x14TorrentSiteForbidden\x10\x01\x12\x15\n" +
	"\x11FilesAlreadyExist\x10\x02\"#\n" +
	"\vSearchQuery\x12\x14\n" +
	"\x05Query\x18\x01 \x01(\tR\x05Query\"\xfb\x01\n" +
	"\x13TVShowDeliveryState\x125\n" +
	"\x04data\x18\x01 \x01(\v2!.mediadelivery.TVShowDeliveryDataR\x04data\x125\n" +
	"\x04step\x18\x02 \x01(\x0e2!.mediadelivery.TVShowDeliveryStepR\x04step\x12-\n" +
	"\x06status\x18\x03 \x01(\x0e2\x15.mediadelivery.StatusR\x06status\x12=\n" +
	"\x05error\x18\x04 \x01(\v2\".mediadelivery.TVShowDeliveryErrorH\x00R\x05error\x88\x01\x01B\b\n" +
	"\x06_error\"T\n" +
	"\x19CreateVideoContentRequest\x127\n" +
	"\n" +
	"content_id\x18\x01 \x01(\v2\x18.mediadelivery.ContentIDR\tcontentId\"Q\n" +
	"\x1aCreateVideoContentResponse\x123\n" +
	"\x06result\x18\x01 \x01(\v2\x1b.mediadelivery.VideoContentR\x06result\"Q\n" +
	"\x16GetVideoContentRequest\x127\n" +
	"\n" +
	"content_id\x18\x01 \x01(\v2\x18.mediadelivery.ContentIDR\tcontentId\"L\n" +
	"\x17GetVideoContentResponse\x121\n" +
	"\x05items\x18\x01 \x03(\v2\x1b.mediadelivery.VideoContentR\x05items\"W\n" +
	"\x1cGetTVShowDeliveryDataRequest\x127\n" +
	"\n" +
	"content_id\x18\x01 \x01(\v2\x18.mediadelivery.ContentIDR\tcontentId\"[\n" +
	"\x1dGetTVShowDeliveryDataResponse\x12:\n" +
	"\x06result\x18\x01 \x01(\v2\".mediadelivery.TVShowDeliveryStateR\x06result\"\xbb\x01\n" +
	"\x1aChoseTorrentOptionsRequest\x127\n" +
	"\n" +
	"content_id\x18\x01 \x01(\v2\x18.mediadelivery.ContentIDR\tcontentId\x12\x17\n" +
	"\x04href\x18\x02 \x01(\tH\x00R\x04href\x88\x01\x01\x12-\n" +
	"\x10new_search_query\x18\x03 \x01(\tH\x01R\x0enewSearchQuery\x88\x01\x01B\a\n" +
	"\x05_hrefB\x13\n" +
	"\x11_new_search_query\"Y\n" +
	"\x1bChoseTorrentOptionsResponse\x12:\n" +
	"\x06result\x18\x01 \x01(\v2\".mediadelivery.TVShowDeliveryStateR\x06result\"\xd4\x01\n" +
	"\x1eChoseFileMatchesOptionsRequest\x127\n" +
	"\n" +
	"content_id\x18\x01 \x01(\v2\x18.mediadelivery.ContentIDR\tcontentId\x12\x18\n" +
	"\aapprove\x18\x02 \x01(\bR\aapprove\x12K\n" +
	"\x0fcontent_matches\x18\x03 \x01(\v2\x1d.mediadelivery.ContentMatchesH\x00R\x0econtentMatches\x88\x01\x01B\x12\n" +
	"\x10_content_matches\"]\n" +
	"\x1fChoseFileMatchesOptionsResponse\x12:\n" +
	"\x06result\x18\x01 \x01(\v2\".mediadelivery.TVShowDeliveryStateR\x06result*\x80\x01\n" +
	"\x0eDeliveryStatus\x12\x19\n" +
	"\x15DeliveryStatusUnknown\x10\x00\x12\x18\n" +
	"\x14DeliveryStatusFailed\x10\x01\x12\x1c\n" +
	"\x18DeliveryStatusInProgress\x10\x02\x12\x1b\n" +
	"\x17DeliveryStatusDelivered\x10\x03*g\n" +
	"\x06Status\x12\x11\n" +
	"\rStatusUnknown\x10\x00\x12\r\n" +
	"\tNewStatus\x10\x01\x12\x14\n" +
	"\x10InProgressStatus\x10\x02\x12\x13\n" +
	"\x0fCompletedStatus\x10\x03\x12\x10\n" +
	"\fFailedStatus\x10\x04*\x8e\x04\n" +
	"\x12TVShowDeliveryStep\x12\x1d\n" +
	"\x19TVShowDeliveryStepUnknown\x10\x00\x12\x17\n" +
	"\x13GenerateSearchQuery\x10\x01\x12\x12\n" +
	"\x0eSearchTorrents\x10\x02\x12\x1b\n" +
	"\x17WaitingUserChoseTorrent\x10\x03\x12\x11\n" +
	"\rGetMagnetLink\x10\x04\x12\x1d\n" +
	"\x19AddTorrentToTorrentClient\x10\x05\x12\x16\n" +
	"\x12PrepareFileMatches\x10\x06\x12\x1b\n" +
	"\x17WaitingChoseFileMatches\x10\a\x12\"\n" +
	"\x1eWaitingTorrentDownloadComplete\x10\b\x12\x1e\n" +
	"\x1aCreateVideoContentCatalogs\x10\t\x12\x1f\n" +
	"\x1bDeterminingNeedConvertFiles\x10\n" +
	"\x12\x18\n" +
	"\x14StartMergeVideoFiles\x10\v\x12\x1a\n" +
	"\x16WaitingMergeVideoFiles\x10\f\x12\x16\n" +
	"\x12CreateHardLinkCopy\x10\r\x12\x13\n" +
	"\x0fGetCatalogsSize\x10\x0f\x12\x14\n" +
	"\x10SetMediaMetaData\x10\x10\x12\x1c\n" +
	"\x18SendDeliveryNotification\x10\x11\x12\x17\n" +
	"\x13WaitingTorrentFiles\x10\x12\x12\x13\n" +
	"\x0fGetEpisodesData\x10\x132\x9f\b\n" +
	"\x13VideoContentService\x12\xb6\x01\n" +
	"\x12CreateVideoContent\x12(.mediadelivery.CreateVideoContentRequest\x1a).mediadelivery.CreateVideoContentResponse\"K\x92A2\x120Создание файловой раздачи\x82\xd3\xe4\x93\x02\x10:\x01*\"\v/v1/content\x12\xc1\x01\n" +
	"\x0fGetVideoContent\x12%.mediadelivery.GetVideoContentRequest\x1a&.mediadelivery.GetVideoContentResponse\"_\x92AI\x12GПолучение доставок для кино/тв сериала\x82\xd3\xe4\x93\x02\r\x12\v/v1/content\x12\xd6\x01\n" +
	"\x15GetTVShowDeliveryData\x12+.mediadelivery.GetTVShowDeliveryDataRequest\x1a,.mediadelivery.GetTVShowDeliveryDataResponse\"b\x92A?\x12=Получение данных стейта доставки\x82\xd3\xe4\x93\x02\x1a\x12\x18/v1/tvshow/delivery/data\x12\xcc\x01\n" +
	"\x13ChoseTorrentOptions\x12).mediadelivery.ChoseTorrentOptionsRequest\x1a*.mediadelivery.ChoseTorrentOptionsResponse\"^\x92A/\x12-Выбор раздачи с торрента\x82\xd3\xe4\x93\x02&:\x01*2!/v1/tvshow/delivery/chose-torrent\x12\xe2\x01\n" +
	"\x17ChoseFileMatchesOptions\x12-.mediadelivery.ChoseFileMatchesOptionsRequest\x1a..mediadelivery.ChoseFileMatchesOptionsResponse\"h\x92A4\x122Подтверждение метча файлов\x82\xd3\xe4\x93\x02+:\x01*2&/v1/tvshow/delivery/chose-file-matchesB'Z%github.com/kkiling/media-delivery/apib\x06proto3"

var (
	file_media_delivery_videocontent_proto_rawDescOnce sync.Once
	file_media_delivery_videocontent_proto_rawDescData []byte
)

func file_media_delivery_videocontent_proto_rawDescGZIP() []byte {
	file_media_delivery_videocontent_proto_rawDescOnce.Do(func() {
		file_media_delivery_videocontent_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_media_delivery_videocontent_proto_rawDesc), len(file_media_delivery_videocontent_proto_rawDesc)))
	})
	return file_media_delivery_videocontent_proto_rawDescData
}

var file_media_delivery_videocontent_proto_enumTypes = make([]protoimpl.EnumInfo, 6)
var file_media_delivery_videocontent_proto_msgTypes = make([]protoimpl.MessageInfo, 28)
var file_media_delivery_videocontent_proto_goTypes = []any{
	(DeliveryStatus)(0),                     // 0: mediadelivery.DeliveryStatus
	(Status)(0),                             // 1: mediadelivery.Status
	(TVShowDeliveryStep)(0),                 // 2: mediadelivery.TVShowDeliveryStep
	(Track_TrackType)(0),                    // 3: mediadelivery.Track.TrackType
	(TorrentDownloadStatus_TorrentState)(0), // 4: mediadelivery.TorrentDownloadStatus.TorrentState
	(TVShowDeliveryError_ErrorType)(0),      // 5: mediadelivery.TVShowDeliveryError.ErrorType
	(*TVShowID)(nil),                        // 6: mediadelivery.TVShowID
	(*ContentID)(nil),                       // 7: mediadelivery.ContentID
	(*VideoContent)(nil),                    // 8: mediadelivery.VideoContent
	(*TorrentSearch)(nil),                   // 9: mediadelivery.TorrentSearch
	(*EpisodeInfo)(nil),                     // 10: mediadelivery.EpisodeInfo
	(*Track)(nil),                           // 11: mediadelivery.Track
	(*ContentMatch)(nil),                    // 12: mediadelivery.ContentMatch
	(*ContentMatches)(nil),                  // 13: mediadelivery.ContentMatches
	(*TorrentDownloadStatus)(nil),           // 14: mediadelivery.TorrentDownloadStatus
	(*MergeVideoStatus)(nil),                // 15: mediadelivery.MergeVideoStatus
	(*TVShowCatalogPath)(nil),               // 16: mediadelivery.TVShowCatalogPath
	(*TVShowCatalog)(nil),                   // 17: mediadelivery.TVShowCatalog
	(*Torrent)(nil),                         // 18: mediadelivery.Torrent
	(*TVShowDeliveryData)(nil),              // 19: mediadelivery.TVShowDeliveryData
	(*TVShowDeliveryError)(nil),             // 20: mediadelivery.TVShowDeliveryError
	(*SearchQuery)(nil),                     // 21: mediadelivery.SearchQuery
	(*TVShowDeliveryState)(nil),             // 22: mediadelivery.TVShowDeliveryState
	(*CreateVideoContentRequest)(nil),       // 23: mediadelivery.CreateVideoContentRequest
	(*CreateVideoContentResponse)(nil),      // 24: mediadelivery.CreateVideoContentResponse
	(*GetVideoContentRequest)(nil),          // 25: mediadelivery.GetVideoContentRequest
	(*GetVideoContentResponse)(nil),         // 26: mediadelivery.GetVideoContentResponse
	(*GetTVShowDeliveryDataRequest)(nil),    // 27: mediadelivery.GetTVShowDeliveryDataRequest
	(*GetTVShowDeliveryDataResponse)(nil),   // 28: mediadelivery.GetTVShowDeliveryDataResponse
	(*ChoseTorrentOptionsRequest)(nil),      // 29: mediadelivery.ChoseTorrentOptionsRequest
	(*ChoseTorrentOptionsResponse)(nil),     // 30: mediadelivery.ChoseTorrentOptionsResponse
	(*ChoseFileMatchesOptionsRequest)(nil),  // 31: mediadelivery.ChoseFileMatchesOptionsRequest
	(*ChoseFileMatchesOptionsResponse)(nil), // 32: mediadelivery.ChoseFileMatchesOptionsResponse
	(*ContentMatches_Options)(nil),          // 33: mediadelivery.ContentMatches.Options
	(*timestamppb.Timestamp)(nil),           // 34: google.protobuf.Timestamp
}
var file_media_delivery_videocontent_proto_depIdxs = []int32{
	6,  // 0: mediadelivery.ContentID.tv_show:type_name -> mediadelivery.TVShowID
	34, // 1: mediadelivery.VideoContent.created_at:type_name -> google.protobuf.Timestamp
	0,  // 2: mediadelivery.VideoContent.delivery_status:type_name -> mediadelivery.DeliveryStatus
	3,  // 3: mediadelivery.Track.type:type_name -> mediadelivery.Track.TrackType
	10, // 4: mediadelivery.ContentMatch.episode:type_name -> mediadelivery.EpisodeInfo
	11, // 5: mediadelivery.ContentMatch.video:type_name -> mediadelivery.Track
	11, // 6: mediadelivery.ContentMatch.audio_tracks:type_name -> mediadelivery.Track
	11, // 7: mediadelivery.ContentMatch.subtitles:type_name -> mediadelivery.Track
	12, // 8: mediadelivery.ContentMatches.matches:type_name -> mediadelivery.ContentMatch
	11, // 9: mediadelivery.ContentMatches.unallocated:type_name -> mediadelivery.Track
	33, // 10: mediadelivery.ContentMatches.options:type_name -> mediadelivery.ContentMatches.Options
	4,  // 11: mediadelivery.TorrentDownloadStatus.state:type_name -> mediadelivery.TorrentDownloadStatus.TorrentState
	16, // 12: mediadelivery.TVShowCatalog.media_server_path:type_name -> mediadelivery.TVShowCatalogPath
	21, // 13: mediadelivery.TVShowDeliveryData.search_query:type_name -> mediadelivery.SearchQuery
	9,  // 14: mediadelivery.TVShowDeliveryData.torrent_search:type_name -> mediadelivery.TorrentSearch
	13, // 15: mediadelivery.TVShowDeliveryData.content_matches:type_name -> mediadelivery.ContentMatches
	14, // 16: mediadelivery.TVShowDeliveryData.torrent_download_status:type_name -> mediadelivery.TorrentDownloadStatus
	15, // 17: mediadelivery.TVShowDeliveryData.merge_video_status:type_name -> mediadelivery.MergeVideoStatus
	17, // 18: mediadelivery.TVShowDeliveryData.tv_show_catalog_info:type_name -> mediadelivery.TVShowCatalog
	18, // 19: mediadelivery.TVShowDeliveryData.torrent:type_name -> mediadelivery.Torrent
	5,  // 20: mediadelivery.TVShowDeliveryError.error_type:type_name -> mediadelivery.TVShowDeliveryError.ErrorType
	19, // 21: mediadelivery.TVShowDeliveryState.data:type_name -> mediadelivery.TVShowDeliveryData
	2,  // 22: mediadelivery.TVShowDeliveryState.step:type_name -> mediadelivery.TVShowDeliveryStep
	1,  // 23: mediadelivery.TVShowDeliveryState.status:type_name -> mediadelivery.Status
	20, // 24: mediadelivery.TVShowDeliveryState.error:type_name -> mediadelivery.TVShowDeliveryError
	7,  // 25: mediadelivery.CreateVideoContentRequest.content_id:type_name -> mediadelivery.ContentID
	8,  // 26: mediadelivery.CreateVideoContentResponse.result:type_name -> mediadelivery.VideoContent
	7,  // 27: mediadelivery.GetVideoContentRequest.content_id:type_name -> mediadelivery.ContentID
	8,  // 28: mediadelivery.GetVideoContentResponse.items:type_name -> mediadelivery.VideoContent
	7,  // 29: mediadelivery.GetTVShowDeliveryDataRequest.content_id:type_name -> mediadelivery.ContentID
	22, // 30: mediadelivery.GetTVShowDeliveryDataResponse.result:type_name -> mediadelivery.TVShowDeliveryState
	7,  // 31: mediadelivery.ChoseTorrentOptionsRequest.content_id:type_name -> mediadelivery.ContentID
	22, // 32: mediadelivery.ChoseTorrentOptionsResponse.result:type_name -> mediadelivery.TVShowDeliveryState
	7,  // 33: mediadelivery.ChoseFileMatchesOptionsRequest.content_id:type_name -> mediadelivery.ContentID
	13, // 34: mediadelivery.ChoseFileMatchesOptionsRequest.content_matches:type_name -> mediadelivery.ContentMatches
	22, // 35: mediadelivery.ChoseFileMatchesOptionsResponse.result:type_name -> mediadelivery.TVShowDeliveryState
	23, // 36: mediadelivery.VideoContentService.CreateVideoContent:input_type -> mediadelivery.CreateVideoContentRequest
	25, // 37: mediadelivery.VideoContentService.GetVideoContent:input_type -> mediadelivery.GetVideoContentRequest
	27, // 38: mediadelivery.VideoContentService.GetTVShowDeliveryData:input_type -> mediadelivery.GetTVShowDeliveryDataRequest
	29, // 39: mediadelivery.VideoContentService.ChoseTorrentOptions:input_type -> mediadelivery.ChoseTorrentOptionsRequest
	31, // 40: mediadelivery.VideoContentService.ChoseFileMatchesOptions:input_type -> mediadelivery.ChoseFileMatchesOptionsRequest
	24, // 41: mediadelivery.VideoContentService.CreateVideoContent:output_type -> mediadelivery.CreateVideoContentResponse
	26, // 42: mediadelivery.VideoContentService.GetVideoContent:output_type -> mediadelivery.GetVideoContentResponse
	28, // 43: mediadelivery.VideoContentService.GetTVShowDeliveryData:output_type -> mediadelivery.GetTVShowDeliveryDataResponse
	30, // 44: mediadelivery.VideoContentService.ChoseTorrentOptions:output_type -> mediadelivery.ChoseTorrentOptionsResponse
	32, // 45: mediadelivery.VideoContentService.ChoseFileMatchesOptions:output_type -> mediadelivery.ChoseFileMatchesOptionsResponse
	41, // [41:46] is the sub-list for method output_type
	36, // [36:41] is the sub-list for method input_type
	36, // [36:36] is the sub-list for extension type_name
	36, // [36:36] is the sub-list for extension extendee
	0,  // [0:36] is the sub-list for field type_name
}

func init() { file_media_delivery_videocontent_proto_init() }
func file_media_delivery_videocontent_proto_init() {
	if File_media_delivery_videocontent_proto != nil {
		return
	}
	file_media_delivery_videocontent_proto_msgTypes[1].OneofWrappers = []any{}
	file_media_delivery_videocontent_proto_msgTypes[5].OneofWrappers = []any{}
	file_media_delivery_videocontent_proto_msgTypes[13].OneofWrappers = []any{}
	file_media_delivery_videocontent_proto_msgTypes[16].OneofWrappers = []any{}
	file_media_delivery_videocontent_proto_msgTypes[23].OneofWrappers = []any{}
	file_media_delivery_videocontent_proto_msgTypes[25].OneofWrappers = []any{}
	file_media_delivery_videocontent_proto_msgTypes[27].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_media_delivery_videocontent_proto_rawDesc), len(file_media_delivery_videocontent_proto_rawDesc)),
			NumEnums:      6,
			NumMessages:   28,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_media_delivery_videocontent_proto_goTypes,
		DependencyIndexes: file_media_delivery_videocontent_proto_depIdxs,
		EnumInfos:         file_media_delivery_videocontent_proto_enumTypes,
		MessageInfos:      file_media_delivery_videocontent_proto_msgTypes,
	}.Build()
	File_media_delivery_videocontent_proto = out.File
	file_media_delivery_videocontent_proto_goTypes = nil
	file_media_delivery_videocontent_proto_depIdxs = nil
}
