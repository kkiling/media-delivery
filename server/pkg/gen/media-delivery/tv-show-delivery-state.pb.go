// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: media-delivery/tv-show-delivery-state.proto

package api

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	_ "github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2/options"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	_ "google.golang.org/protobuf/types/known/emptypb"
	_ "google.golang.org/protobuf/types/known/timestamppb"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type TVShowDeliveryStep int32

const (
	// Неизвестный статус доставки
	TVShowDeliveryStep_TVShowDeliveryStepUnknown TVShowDeliveryStep = 0
	// Генерация запроса к трекеру
	TVShowDeliveryStep_GenerateSearchQuery TVShowDeliveryStep = 1
	// Поиск раздач сезона сериала/фильма
	TVShowDeliveryStep_SearchTorrents TVShowDeliveryStep = 2
	// Ожидание выбора раздачи пользователем
	TVShowDeliveryStep_WaitingUserChoseTorrent TVShowDeliveryStep = 3
	// Получение магнет ссылки
	TVShowDeliveryStep_GetMagnetLink TVShowDeliveryStep = 4
	// Добавление раздачи для скачивания торрент клиентом
	TVShowDeliveryStep_AddTorrentToTorrentClient TVShowDeliveryStep = 5
	// Получение информации о файлах раздачи
	TVShowDeliveryStep_PrepareFileMatches TVShowDeliveryStep = 6
	// Ожидание подтверждения пользователем соответствий выбора файлов
	TVShowDeliveryStep_WaitingChoseFileMatches TVShowDeliveryStep = 7
	// Ожидание завершения окончания скачивания раздачи
	TVShowDeliveryStep_WaitingTorrentDownloadComplete TVShowDeliveryStep = 8
	// Формирование каталогов и иерархии файлов
	TVShowDeliveryStep_CreateVideoContentCatalogs TVShowDeliveryStep = 9
	// Определение необходимости конвертации файлов
	TVShowDeliveryStep_DeterminingNeedConvertFiles TVShowDeliveryStep = 10
	// Запуск конвертирования файлов
	TVShowDeliveryStep_StartMergeVideoFiles TVShowDeliveryStep = 11
	// Ожидание завершения конвертации файлов
	TVShowDeliveryStep_WaitingMergeVideoFiles TVShowDeliveryStep = 12
	// Копирование файлов из раздачи в каталог медиасервера (точнее создание симлинков)
	TVShowDeliveryStep_CreateHardLinkCopy TVShowDeliveryStep = 13
	// GetCatalogsSize получение размеров каталогов сериала
	TVShowDeliveryStep_GetCatalogsSize TVShowDeliveryStep = 15
	// Установка методаных серий сезона сериала/фильма в медиасервере
	TVShowDeliveryStep_SetMediaMetaData TVShowDeliveryStep = 16
	// Отправка уведомления в telegramm о успешной доставки
	TVShowDeliveryStep_SendDeliveryNotification TVShowDeliveryStep = 17
	// Ожидание когда появится информация о файлах в раздаче
	TVShowDeliveryStep_WaitingTorrentFiles TVShowDeliveryStep = 18
	// получение информации о эпизодах и каталоге сезона
	TVShowDeliveryStep_GetEpisodesData TVShowDeliveryStep = 19
)

// Enum value maps for TVShowDeliveryStep.
var (
	TVShowDeliveryStep_name = map[int32]string{
		0:  "TVShowDeliveryStepUnknown",
		1:  "GenerateSearchQuery",
		2:  "SearchTorrents",
		3:  "WaitingUserChoseTorrent",
		4:  "GetMagnetLink",
		5:  "AddTorrentToTorrentClient",
		6:  "PrepareFileMatches",
		7:  "WaitingChoseFileMatches",
		8:  "WaitingTorrentDownloadComplete",
		9:  "CreateVideoContentCatalogs",
		10: "DeterminingNeedConvertFiles",
		11: "StartMergeVideoFiles",
		12: "WaitingMergeVideoFiles",
		13: "CreateHardLinkCopy",
		15: "GetCatalogsSize",
		16: "SetMediaMetaData",
		17: "SendDeliveryNotification",
		18: "WaitingTorrentFiles",
		19: "GetEpisodesData",
	}
	TVShowDeliveryStep_value = map[string]int32{
		"TVShowDeliveryStepUnknown":      0,
		"GenerateSearchQuery":            1,
		"SearchTorrents":                 2,
		"WaitingUserChoseTorrent":        3,
		"GetMagnetLink":                  4,
		"AddTorrentToTorrentClient":      5,
		"PrepareFileMatches":             6,
		"WaitingChoseFileMatches":        7,
		"WaitingTorrentDownloadComplete": 8,
		"CreateVideoContentCatalogs":     9,
		"DeterminingNeedConvertFiles":    10,
		"StartMergeVideoFiles":           11,
		"WaitingMergeVideoFiles":         12,
		"CreateHardLinkCopy":             13,
		"GetCatalogsSize":                15,
		"SetMediaMetaData":               16,
		"SendDeliveryNotification":       17,
		"WaitingTorrentFiles":            18,
		"GetEpisodesData":                19,
	}
)

func (x TVShowDeliveryStep) Enum() *TVShowDeliveryStep {
	p := new(TVShowDeliveryStep)
	*p = x
	return p
}

func (x TVShowDeliveryStep) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TVShowDeliveryStep) Descriptor() protoreflect.EnumDescriptor {
	return file_media_delivery_tv_show_delivery_state_proto_enumTypes[0].Descriptor()
}

func (TVShowDeliveryStep) Type() protoreflect.EnumType {
	return &file_media_delivery_tv_show_delivery_state_proto_enumTypes[0]
}

func (x TVShowDeliveryStep) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TVShowDeliveryStep.Descriptor instead.
func (TVShowDeliveryStep) EnumDescriptor() ([]byte, []int) {
	return file_media_delivery_tv_show_delivery_state_proto_rawDescGZIP(), []int{0}
}

type TVShowDeliveryError_ErrorType int32

const (
	TVShowDeliveryError_TVShowDeliveryError_Unknown TVShowDeliveryError_ErrorType = 0
	// Торрент трекер не доступен
	TVShowDeliveryError_TorrentSiteForbidden TVShowDeliveryError_ErrorType = 1
	// Файлы на медиасервере уже существуют
	TVShowDeliveryError_FilesAlreadyExist TVShowDeliveryError_ErrorType = 2
)

// Enum value maps for TVShowDeliveryError_ErrorType.
var (
	TVShowDeliveryError_ErrorType_name = map[int32]string{
		0: "TVShowDeliveryError_Unknown",
		1: "TorrentSiteForbidden",
		2: "FilesAlreadyExist",
	}
	TVShowDeliveryError_ErrorType_value = map[string]int32{
		"TVShowDeliveryError_Unknown": 0,
		"TorrentSiteForbidden":        1,
		"FilesAlreadyExist":           2,
	}
)

func (x TVShowDeliveryError_ErrorType) Enum() *TVShowDeliveryError_ErrorType {
	p := new(TVShowDeliveryError_ErrorType)
	*p = x
	return p
}

func (x TVShowDeliveryError_ErrorType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TVShowDeliveryError_ErrorType) Descriptor() protoreflect.EnumDescriptor {
	return file_media_delivery_tv_show_delivery_state_proto_enumTypes[1].Descriptor()
}

func (TVShowDeliveryError_ErrorType) Type() protoreflect.EnumType {
	return &file_media_delivery_tv_show_delivery_state_proto_enumTypes[1]
}

func (x TVShowDeliveryError_ErrorType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TVShowDeliveryError_ErrorType.Descriptor instead.
func (TVShowDeliveryError_ErrorType) EnumDescriptor() ([]byte, []int) {
	return file_media_delivery_tv_show_delivery_state_proto_rawDescGZIP(), []int{0, 0}
}

type Track_TrackType int32

const (
	Track_TRACK_TYPE_UNKNOWN  Track_TrackType = 0
	Track_TRACK_TYPE_VIDEO    Track_TrackType = 1
	Track_TRACK_TYPE_AUDIO    Track_TrackType = 2
	Track_TRACK_TYPE_SUBTITLE Track_TrackType = 3
)

// Enum value maps for Track_TrackType.
var (
	Track_TrackType_name = map[int32]string{
		0: "TRACK_TYPE_UNKNOWN",
		1: "TRACK_TYPE_VIDEO",
		2: "TRACK_TYPE_AUDIO",
		3: "TRACK_TYPE_SUBTITLE",
	}
	Track_TrackType_value = map[string]int32{
		"TRACK_TYPE_UNKNOWN":  0,
		"TRACK_TYPE_VIDEO":    1,
		"TRACK_TYPE_AUDIO":    2,
		"TRACK_TYPE_SUBTITLE": 3,
	}
)

func (x Track_TrackType) Enum() *Track_TrackType {
	p := new(Track_TrackType)
	*p = x
	return p
}

func (x Track_TrackType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Track_TrackType) Descriptor() protoreflect.EnumDescriptor {
	return file_media_delivery_tv_show_delivery_state_proto_enumTypes[2].Descriptor()
}

func (Track_TrackType) Type() protoreflect.EnumType {
	return &file_media_delivery_tv_show_delivery_state_proto_enumTypes[2]
}

func (x Track_TrackType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Track_TrackType.Descriptor instead.
func (Track_TrackType) EnumDescriptor() ([]byte, []int) {
	return file_media_delivery_tv_show_delivery_state_proto_rawDescGZIP(), []int{2, 0}
}

type TorrentDownloadStatus_TorrentState int32

const (
	TorrentDownloadStatus_TORRENT_STATE_UNKNOWN     TorrentDownloadStatus_TorrentState = 0
	TorrentDownloadStatus_TORRENT_STATE_ERROR       TorrentDownloadStatus_TorrentState = 1
	TorrentDownloadStatus_TORRENT_STATE_UPLOADING   TorrentDownloadStatus_TorrentState = 2
	TorrentDownloadStatus_TORRENT_STATE_DOWNLOADING TorrentDownloadStatus_TorrentState = 3
	TorrentDownloadStatus_TORRENT_STATE_STOPPED     TorrentDownloadStatus_TorrentState = 4
	TorrentDownloadStatus_TORRENT_STATE_QUEUED      TorrentDownloadStatus_TorrentState = 5
)

// Enum value maps for TorrentDownloadStatus_TorrentState.
var (
	TorrentDownloadStatus_TorrentState_name = map[int32]string{
		0: "TORRENT_STATE_UNKNOWN",
		1: "TORRENT_STATE_ERROR",
		2: "TORRENT_STATE_UPLOADING",
		3: "TORRENT_STATE_DOWNLOADING",
		4: "TORRENT_STATE_STOPPED",
		5: "TORRENT_STATE_QUEUED",
	}
	TorrentDownloadStatus_TorrentState_value = map[string]int32{
		"TORRENT_STATE_UNKNOWN":     0,
		"TORRENT_STATE_ERROR":       1,
		"TORRENT_STATE_UPLOADING":   2,
		"TORRENT_STATE_DOWNLOADING": 3,
		"TORRENT_STATE_STOPPED":     4,
		"TORRENT_STATE_QUEUED":      5,
	}
)

func (x TorrentDownloadStatus_TorrentState) Enum() *TorrentDownloadStatus_TorrentState {
	p := new(TorrentDownloadStatus_TorrentState)
	*p = x
	return p
}

func (x TorrentDownloadStatus_TorrentState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TorrentDownloadStatus_TorrentState) Descriptor() protoreflect.EnumDescriptor {
	return file_media_delivery_tv_show_delivery_state_proto_enumTypes[3].Descriptor()
}

func (TorrentDownloadStatus_TorrentState) Type() protoreflect.EnumType {
	return &file_media_delivery_tv_show_delivery_state_proto_enumTypes[3]
}

func (x TorrentDownloadStatus_TorrentState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TorrentDownloadStatus_TorrentState.Descriptor instead.
func (TorrentDownloadStatus_TorrentState) EnumDescriptor() ([]byte, []int) {
	return file_media_delivery_tv_show_delivery_state_proto_rawDescGZIP(), []int{9, 0}
}

type TVShowDeliveryError struct {
	state         protoimpl.MessageState        `protogen:"open.v1"`
	RawError      string                        `protobuf:"bytes,1,opt,name=raw_error,json=rawError,proto3" json:"raw_error,omitempty"`
	ErrorType     TVShowDeliveryError_ErrorType `protobuf:"varint,2,opt,name=error_type,json=errorType,proto3,enum=mediadelivery.TVShowDeliveryError_ErrorType" json:"error_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TVShowDeliveryError) Reset() {
	*x = TVShowDeliveryError{}
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TVShowDeliveryError) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TVShowDeliveryError) ProtoMessage() {}

func (x *TVShowDeliveryError) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TVShowDeliveryError.ProtoReflect.Descriptor instead.
func (*TVShowDeliveryError) Descriptor() ([]byte, []int) {
	return file_media_delivery_tv_show_delivery_state_proto_rawDescGZIP(), []int{0}
}

func (x *TVShowDeliveryError) GetRawError() string {
	if x != nil {
		return x.RawError
	}
	return ""
}

func (x *TVShowDeliveryError) GetErrorType() TVShowDeliveryError_ErrorType {
	if x != nil {
		return x.ErrorType
	}
	return TVShowDeliveryError_TVShowDeliveryError_Unknown
}

type TVShowDeliveryState struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Data          *TVShowDeliveryData    `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Step          TVShowDeliveryStep     `protobuf:"varint,2,opt,name=step,proto3,enum=mediadelivery.TVShowDeliveryStep" json:"step,omitempty"`
	Status        StateStatus            `protobuf:"varint,3,opt,name=status,proto3,enum=mediadelivery.StateStatus" json:"status,omitempty"`
	Error         *TVShowDeliveryError   `protobuf:"bytes,4,opt,name=error,proto3,oneof" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TVShowDeliveryState) Reset() {
	*x = TVShowDeliveryState{}
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TVShowDeliveryState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TVShowDeliveryState) ProtoMessage() {}

func (x *TVShowDeliveryState) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TVShowDeliveryState.ProtoReflect.Descriptor instead.
func (*TVShowDeliveryState) Descriptor() ([]byte, []int) {
	return file_media_delivery_tv_show_delivery_state_proto_rawDescGZIP(), []int{1}
}

func (x *TVShowDeliveryState) GetData() *TVShowDeliveryData {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *TVShowDeliveryState) GetStep() TVShowDeliveryStep {
	if x != nil {
		return x.Step
	}
	return TVShowDeliveryStep_TVShowDeliveryStepUnknown
}

func (x *TVShowDeliveryState) GetStatus() StateStatus {
	if x != nil {
		return x.Status
	}
	return StateStatus_StatusUnknown
}

func (x *TVShowDeliveryState) GetError() *TVShowDeliveryError {
	if x != nil {
		return x.Error
	}
	return nil
}

type Track struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	RelativePath  string                 `protobuf:"bytes,1,opt,name=relative_path,json=relativePath,proto3" json:"relative_path,omitempty"`
	FullPath      string                 `protobuf:"bytes,2,opt,name=full_path,json=fullPath,proto3" json:"full_path,omitempty"`
	Name          *string                `protobuf:"bytes,3,opt,name=name,proto3,oneof" json:"name,omitempty"`
	Language      *string                `protobuf:"bytes,4,opt,name=language,proto3,oneof" json:"language,omitempty"`
	Type          Track_TrackType        `protobuf:"varint,5,opt,name=type,proto3,enum=mediadelivery.Track_TrackType" json:"type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Track) Reset() {
	*x = Track{}
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Track) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Track) ProtoMessage() {}

func (x *Track) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Track.ProtoReflect.Descriptor instead.
func (*Track) Descriptor() ([]byte, []int) {
	return file_media_delivery_tv_show_delivery_state_proto_rawDescGZIP(), []int{2}
}

func (x *Track) GetRelativePath() string {
	if x != nil {
		return x.RelativePath
	}
	return ""
}

func (x *Track) GetFullPath() string {
	if x != nil {
		return x.FullPath
	}
	return ""
}

func (x *Track) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *Track) GetLanguage() string {
	if x != nil && x.Language != nil {
		return *x.Language
	}
	return ""
}

func (x *Track) GetType() Track_TrackType {
	if x != nil {
		return x.Type
	}
	return Track_TRACK_TYPE_UNKNOWN
}

type SearchQuery struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Query         string                 `protobuf:"bytes,1,opt,name=Query,proto3" json:"Query,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SearchQuery) Reset() {
	*x = SearchQuery{}
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SearchQuery) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SearchQuery) ProtoMessage() {}

func (x *SearchQuery) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SearchQuery.ProtoReflect.Descriptor instead.
func (*SearchQuery) Descriptor() ([]byte, []int) {
	return file_media_delivery_tv_show_delivery_state_proto_rawDescGZIP(), []int{3}
}

func (x *SearchQuery) GetQuery() string {
	if x != nil {
		return x.Query
	}
	return ""
}

type TorrentSearch struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Title         string                 `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Href          string                 `protobuf:"bytes,2,opt,name=href,proto3" json:"href,omitempty"`
	Category      string                 `protobuf:"bytes,8,opt,name=category,proto3" json:"category,omitempty"`
	Size          string                 `protobuf:"bytes,3,opt,name=size,proto3" json:"size,omitempty"`
	Seeds         int64                  `protobuf:"varint,4,opt,name=seeds,proto3" json:"seeds,omitempty"`
	Leeches       int64                  `protobuf:"varint,5,opt,name=leeches,proto3" json:"leeches,omitempty"`
	Downloads     int64                  `protobuf:"varint,6,opt,name=downloads,proto3" json:"downloads,omitempty"`
	AddedDate     string                 `protobuf:"bytes,7,opt,name=added_date,json=addedDate,proto3" json:"added_date,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TorrentSearch) Reset() {
	*x = TorrentSearch{}
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TorrentSearch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TorrentSearch) ProtoMessage() {}

func (x *TorrentSearch) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TorrentSearch.ProtoReflect.Descriptor instead.
func (*TorrentSearch) Descriptor() ([]byte, []int) {
	return file_media_delivery_tv_show_delivery_state_proto_rawDescGZIP(), []int{4}
}

func (x *TorrentSearch) GetTitle() string {
	if x != nil {
		return x.Title
	}
	return ""
}

func (x *TorrentSearch) GetHref() string {
	if x != nil {
		return x.Href
	}
	return ""
}

func (x *TorrentSearch) GetCategory() string {
	if x != nil {
		return x.Category
	}
	return ""
}

func (x *TorrentSearch) GetSize() string {
	if x != nil {
		return x.Size
	}
	return ""
}

func (x *TorrentSearch) GetSeeds() int64 {
	if x != nil {
		return x.Seeds
	}
	return 0
}

func (x *TorrentSearch) GetLeeches() int64 {
	if x != nil {
		return x.Leeches
	}
	return 0
}

func (x *TorrentSearch) GetDownloads() int64 {
	if x != nil {
		return x.Downloads
	}
	return 0
}

func (x *TorrentSearch) GetAddedDate() string {
	if x != nil {
		return x.AddedDate
	}
	return ""
}

type EpisodeInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SeasonNumber  uint32                 `protobuf:"varint,1,opt,name=season_number,json=seasonNumber,proto3" json:"season_number,omitempty"`
	EpisodeNumber uint32                 `protobuf:"varint,2,opt,name=episode_number,json=episodeNumber,proto3" json:"episode_number,omitempty"`
	FullPath      string                 `protobuf:"bytes,3,opt,name=full_path,json=fullPath,proto3" json:"full_path,omitempty"`
	RelativePath  string                 `protobuf:"bytes,4,opt,name=relative_path,json=relativePath,proto3" json:"relative_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EpisodeInfo) Reset() {
	*x = EpisodeInfo{}
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EpisodeInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EpisodeInfo) ProtoMessage() {}

func (x *EpisodeInfo) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EpisodeInfo.ProtoReflect.Descriptor instead.
func (*EpisodeInfo) Descriptor() ([]byte, []int) {
	return file_media_delivery_tv_show_delivery_state_proto_rawDescGZIP(), []int{5}
}

func (x *EpisodeInfo) GetSeasonNumber() uint32 {
	if x != nil {
		return x.SeasonNumber
	}
	return 0
}

func (x *EpisodeInfo) GetEpisodeNumber() uint32 {
	if x != nil {
		return x.EpisodeNumber
	}
	return 0
}

func (x *EpisodeInfo) GetFullPath() string {
	if x != nil {
		return x.FullPath
	}
	return ""
}

func (x *EpisodeInfo) GetRelativePath() string {
	if x != nil {
		return x.RelativePath
	}
	return ""
}

type ContentMatch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Инфа о сезоне
	Episode *EpisodeInfo `protobuf:"bytes,1,opt,name=episode,proto3" json:"episode,omitempty"`
	// Видеодорожка
	Video *Track `protobuf:"bytes,2,opt,name=video,proto3" json:"video,omitempty"`
	// Аудиодорожки
	AudioTracks []*Track `protobuf:"bytes,3,rep,name=audio_tracks,json=audioTracks,proto3" json:"audio_tracks,omitempty"`
	// Субтитры
	Subtitles     []*Track `protobuf:"bytes,4,rep,name=subtitles,proto3" json:"subtitles,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ContentMatch) Reset() {
	*x = ContentMatch{}
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ContentMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContentMatch) ProtoMessage() {}

func (x *ContentMatch) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContentMatch.ProtoReflect.Descriptor instead.
func (*ContentMatch) Descriptor() ([]byte, []int) {
	return file_media_delivery_tv_show_delivery_state_proto_rawDescGZIP(), []int{6}
}

func (x *ContentMatch) GetEpisode() *EpisodeInfo {
	if x != nil {
		return x.Episode
	}
	return nil
}

func (x *ContentMatch) GetVideo() *Track {
	if x != nil {
		return x.Video
	}
	return nil
}

func (x *ContentMatch) GetAudioTracks() []*Track {
	if x != nil {
		return x.AudioTracks
	}
	return nil
}

func (x *ContentMatch) GetSubtitles() []*Track {
	if x != nil {
		return x.Subtitles
	}
	return nil
}

type ContentMatches struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Matches []*ContentMatch        `protobuf:"bytes,1,rep,name=matches,proto3" json:"matches,omitempty"`
	// Нераспредленные треки
	Unallocated []*Track `protobuf:"bytes,2,rep,name=unallocated,proto3" json:"unallocated,omitempty"`
	// Опции
	Options       *ContentMatches_Options `protobuf:"bytes,3,opt,name=options,proto3" json:"options,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ContentMatches) Reset() {
	*x = ContentMatches{}
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ContentMatches) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContentMatches) ProtoMessage() {}

func (x *ContentMatches) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContentMatches.ProtoReflect.Descriptor instead.
func (*ContentMatches) Descriptor() ([]byte, []int) {
	return file_media_delivery_tv_show_delivery_state_proto_rawDescGZIP(), []int{7}
}

func (x *ContentMatches) GetMatches() []*ContentMatch {
	if x != nil {
		return x.Matches
	}
	return nil
}

func (x *ContentMatches) GetUnallocated() []*Track {
	if x != nil {
		return x.Unallocated
	}
	return nil
}

func (x *ContentMatches) GetOptions() *ContentMatches_Options {
	if x != nil {
		return x.Options
	}
	return nil
}

type ChoseFileMatchesOptionsRequest struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	ContentId *ContentID             `protobuf:"bytes,1,opt,name=content_id,json=contentId,proto3" json:"content_id,omitempty"`
	// Пользователь подтверждает сметченные файлы
	Approve bool `protobuf:"varint,2,opt,name=approve,proto3" json:"approve,omitempty"`
	// Метч контента, если захотели изменить
	ContentMatches *ContentMatches `protobuf:"bytes,3,opt,name=content_matches,json=contentMatches,proto3,oneof" json:"content_matches,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ChoseFileMatchesOptionsRequest) Reset() {
	*x = ChoseFileMatchesOptionsRequest{}
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChoseFileMatchesOptionsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChoseFileMatchesOptionsRequest) ProtoMessage() {}

func (x *ChoseFileMatchesOptionsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChoseFileMatchesOptionsRequest.ProtoReflect.Descriptor instead.
func (*ChoseFileMatchesOptionsRequest) Descriptor() ([]byte, []int) {
	return file_media_delivery_tv_show_delivery_state_proto_rawDescGZIP(), []int{8}
}

func (x *ChoseFileMatchesOptionsRequest) GetContentId() *ContentID {
	if x != nil {
		return x.ContentId
	}
	return nil
}

func (x *ChoseFileMatchesOptionsRequest) GetApprove() bool {
	if x != nil {
		return x.Approve
	}
	return false
}

func (x *ChoseFileMatchesOptionsRequest) GetContentMatches() *ContentMatches {
	if x != nil {
		return x.ContentMatches
	}
	return nil
}

type TorrentDownloadStatus struct {
	state         protoimpl.MessageState             `protogen:"open.v1"`
	State         TorrentDownloadStatus_TorrentState `protobuf:"varint,1,opt,name=state,proto3,enum=mediadelivery.TorrentDownloadStatus_TorrentState" json:"state,omitempty"`
	Progress      float32                            `protobuf:"fixed32,2,opt,name=progress,proto3" json:"progress,omitempty"`
	IsComplete    bool                               `protobuf:"varint,3,opt,name=is_complete,json=isComplete,proto3" json:"is_complete,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TorrentDownloadStatus) Reset() {
	*x = TorrentDownloadStatus{}
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TorrentDownloadStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TorrentDownloadStatus) ProtoMessage() {}

func (x *TorrentDownloadStatus) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TorrentDownloadStatus.ProtoReflect.Descriptor instead.
func (*TorrentDownloadStatus) Descriptor() ([]byte, []int) {
	return file_media_delivery_tv_show_delivery_state_proto_rawDescGZIP(), []int{9}
}

func (x *TorrentDownloadStatus) GetState() TorrentDownloadStatus_TorrentState {
	if x != nil {
		return x.State
	}
	return TorrentDownloadStatus_TORRENT_STATE_UNKNOWN
}

func (x *TorrentDownloadStatus) GetProgress() float32 {
	if x != nil {
		return x.Progress
	}
	return 0
}

func (x *TorrentDownloadStatus) GetIsComplete() bool {
	if x != nil {
		return x.IsComplete
	}
	return false
}

type MergeVideoStatus struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Progress      float32                `protobuf:"fixed32,1,opt,name=progress,proto3" json:"progress,omitempty"`
	IsComplete    bool                   `protobuf:"varint,2,opt,name=is_complete,json=isComplete,proto3" json:"is_complete,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MergeVideoStatus) Reset() {
	*x = MergeVideoStatus{}
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MergeVideoStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MergeVideoStatus) ProtoMessage() {}

func (x *MergeVideoStatus) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MergeVideoStatus.ProtoReflect.Descriptor instead.
func (*MergeVideoStatus) Descriptor() ([]byte, []int) {
	return file_media_delivery_tv_show_delivery_state_proto_rawDescGZIP(), []int{10}
}

func (x *MergeVideoStatus) GetProgress() float32 {
	if x != nil {
		return x.Progress
	}
	return 0
}

func (x *MergeVideoStatus) GetIsComplete() bool {
	if x != nil {
		return x.IsComplete
	}
	return false
}

type TVShowCatalogPath struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Путь до каталога сериала
	TvShowPath string `protobuf:"bytes,1,opt,name=tv_show_path,json=tvShowPath,proto3" json:"tv_show_path,omitempty"`
	// Путь до каталога сезона (относительно каталога сериала)
	SeasonPath    string `protobuf:"bytes,2,opt,name=season_path,json=seasonPath,proto3" json:"season_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TVShowCatalogPath) Reset() {
	*x = TVShowCatalogPath{}
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TVShowCatalogPath) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TVShowCatalogPath) ProtoMessage() {}

func (x *TVShowCatalogPath) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TVShowCatalogPath.ProtoReflect.Descriptor instead.
func (*TVShowCatalogPath) Descriptor() ([]byte, []int) {
	return file_media_delivery_tv_show_delivery_state_proto_rawDescGZIP(), []int{11}
}

func (x *TVShowCatalogPath) GetTvShowPath() string {
	if x != nil {
		return x.TvShowPath
	}
	return ""
}

func (x *TVShowCatalogPath) GetSeasonPath() string {
	if x != nil {
		return x.SeasonPath
	}
	return ""
}

type TVShowCatalog struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Путь до раздачи сезона сериала
	TorrentPath string `protobuf:"bytes,1,opt,name=torrent_path,json=torrentPath,proto3" json:"torrent_path,omitempty"`
	// Размер файлов раздачи сезона сериала
	TorrentSizePretty string `protobuf:"bytes,2,opt,name=torrent_size_pretty,json=torrentSizePretty,proto3" json:"torrent_size_pretty,omitempty"`
	// Путь до сезона сериала на медиасервере
	MediaServerPath *TVShowCatalogPath `protobuf:"bytes,3,opt,name=media_server_path,json=mediaServerPath,proto3" json:"media_server_path,omitempty"`
	// Размер файлов раздачи сезона сериала (байты)
	MediaServerSizePretty string `protobuf:"bytes,4,opt,name=media_server_size_pretty,json=mediaServerSizePretty,proto3" json:"media_server_size_pretty,omitempty"`
	// Файлы скопированы с раздачи или созданы ссылочная связь
	// True - файлы скопированы
	// False - файлы созданы через линки
	IsCopyFilesInMediaServer bool `protobuf:"varint,5,opt,name=is_copy_files_in_media_server,json=isCopyFilesInMediaServer,proto3" json:"is_copy_files_in_media_server,omitempty"`
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *TVShowCatalog) Reset() {
	*x = TVShowCatalog{}
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TVShowCatalog) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TVShowCatalog) ProtoMessage() {}

func (x *TVShowCatalog) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TVShowCatalog.ProtoReflect.Descriptor instead.
func (*TVShowCatalog) Descriptor() ([]byte, []int) {
	return file_media_delivery_tv_show_delivery_state_proto_rawDescGZIP(), []int{12}
}

func (x *TVShowCatalog) GetTorrentPath() string {
	if x != nil {
		return x.TorrentPath
	}
	return ""
}

func (x *TVShowCatalog) GetTorrentSizePretty() string {
	if x != nil {
		return x.TorrentSizePretty
	}
	return ""
}

func (x *TVShowCatalog) GetMediaServerPath() *TVShowCatalogPath {
	if x != nil {
		return x.MediaServerPath
	}
	return nil
}

func (x *TVShowCatalog) GetMediaServerSizePretty() string {
	if x != nil {
		return x.MediaServerSizePretty
	}
	return ""
}

func (x *TVShowCatalog) GetIsCopyFilesInMediaServer() bool {
	if x != nil {
		return x.IsCopyFilesInMediaServer
	}
	return false
}

type Torrent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Ссылка на раздачу
	Href          string `protobuf:"bytes,1,opt,name=href,proto3" json:"href,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Torrent) Reset() {
	*x = Torrent{}
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Torrent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Torrent) ProtoMessage() {}

func (x *Torrent) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Torrent.ProtoReflect.Descriptor instead.
func (*Torrent) Descriptor() ([]byte, []int) {
	return file_media_delivery_tv_show_delivery_state_proto_rawDescGZIP(), []int{13}
}

func (x *Torrent) GetHref() string {
	if x != nil {
		return x.Href
	}
	return ""
}

type TVShowDeliveryData struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Поисковый запрос поиска торрент файла
	SearchQuery *SearchQuery `protobuf:"bytes,1,opt,name=search_query,json=searchQuery,proto3,oneof" json:"search_query,omitempty"`
	// Результат поиска торрент раздач
	TorrentSearch []*TorrentSearch `protobuf:"bytes,2,rep,name=torrent_search,json=torrentSearch,proto3" json:"torrent_search,omitempty"`
	// Результат метча файлов
	ContentMatches *ContentMatches `protobuf:"bytes,3,opt,name=content_matches,json=contentMatches,proto3,oneof" json:"content_matches,omitempty"`
	// статус скачивания раздачи
	TorrentDownloadStatus *TorrentDownloadStatus `protobuf:"bytes,4,opt,name=torrent_download_status,json=torrentDownloadStatus,proto3,oneof" json:"torrent_download_status,omitempty"`
	// статус сшивания файлов
	MergeVideoStatus *MergeVideoStatus `protobuf:"bytes,5,opt,name=merge_video_status,json=mergeVideoStatus,proto3,oneof" json:"merge_video_status,omitempty"`
	// TVShowCatalogInfo информация о каталогах сериала
	TvShowCatalogInfo *TVShowCatalog `protobuf:"bytes,6,opt,name=tv_show_catalog_info,json=tvShowCatalogInfo,proto3,oneof" json:"tv_show_catalog_info,omitempty"`
	// Информация о раздаче
	Torrent       *Torrent `protobuf:"bytes,7,opt,name=torrent,proto3,oneof" json:"torrent,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TVShowDeliveryData) Reset() {
	*x = TVShowDeliveryData{}
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TVShowDeliveryData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TVShowDeliveryData) ProtoMessage() {}

func (x *TVShowDeliveryData) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TVShowDeliveryData.ProtoReflect.Descriptor instead.
func (*TVShowDeliveryData) Descriptor() ([]byte, []int) {
	return file_media_delivery_tv_show_delivery_state_proto_rawDescGZIP(), []int{14}
}

func (x *TVShowDeliveryData) GetSearchQuery() *SearchQuery {
	if x != nil {
		return x.SearchQuery
	}
	return nil
}

func (x *TVShowDeliveryData) GetTorrentSearch() []*TorrentSearch {
	if x != nil {
		return x.TorrentSearch
	}
	return nil
}

func (x *TVShowDeliveryData) GetContentMatches() *ContentMatches {
	if x != nil {
		return x.ContentMatches
	}
	return nil
}

func (x *TVShowDeliveryData) GetTorrentDownloadStatus() *TorrentDownloadStatus {
	if x != nil {
		return x.TorrentDownloadStatus
	}
	return nil
}

func (x *TVShowDeliveryData) GetMergeVideoStatus() *MergeVideoStatus {
	if x != nil {
		return x.MergeVideoStatus
	}
	return nil
}

func (x *TVShowDeliveryData) GetTvShowCatalogInfo() *TVShowCatalog {
	if x != nil {
		return x.TvShowCatalogInfo
	}
	return nil
}

func (x *TVShowDeliveryData) GetTorrent() *Torrent {
	if x != nil {
		return x.Torrent
	}
	return nil
}

type ContentMatches_Options struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Оставлять оригинальные аудиодорожки (если они есть)
	KeepOriginalAudio bool `protobuf:"varint,1,opt,name=keep_original_audio,json=keepOriginalAudio,proto3" json:"keep_original_audio,omitempty"`
	// Оставлять оригинальные субтитры (если они есть)
	KeepOriginalSubtitles bool `protobuf:"varint,2,opt,name=keep_original_subtitles,json=keepOriginalSubtitles,proto3" json:"keep_original_subtitles,omitempty"`
	// Дефолтная аудиодорожка
	DefaultAudioTrackName *string `protobuf:"bytes,3,opt,name=default_audio_track_name,json=defaultAudioTrackName,proto3,oneof" json:"default_audio_track_name,omitempty"`
	// Дефолтные субтитры
	DefaultSubtitleTrack *string `protobuf:"bytes,4,opt,name=default_subtitle_track,json=defaultSubtitleTrack,proto3,oneof" json:"default_subtitle_track,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *ContentMatches_Options) Reset() {
	*x = ContentMatches_Options{}
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ContentMatches_Options) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContentMatches_Options) ProtoMessage() {}

func (x *ContentMatches_Options) ProtoReflect() protoreflect.Message {
	mi := &file_media_delivery_tv_show_delivery_state_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContentMatches_Options.ProtoReflect.Descriptor instead.
func (*ContentMatches_Options) Descriptor() ([]byte, []int) {
	return file_media_delivery_tv_show_delivery_state_proto_rawDescGZIP(), []int{7, 0}
}

func (x *ContentMatches_Options) GetKeepOriginalAudio() bool {
	if x != nil {
		return x.KeepOriginalAudio
	}
	return false
}

func (x *ContentMatches_Options) GetKeepOriginalSubtitles() bool {
	if x != nil {
		return x.KeepOriginalSubtitles
	}
	return false
}

func (x *ContentMatches_Options) GetDefaultAudioTrackName() string {
	if x != nil && x.DefaultAudioTrackName != nil {
		return *x.DefaultAudioTrackName
	}
	return ""
}

func (x *ContentMatches_Options) GetDefaultSubtitleTrack() string {
	if x != nil && x.DefaultSubtitleTrack != nil {
		return *x.DefaultSubtitleTrack
	}
	return ""
}

var File_media_delivery_tv_show_delivery_state_proto protoreflect.FileDescriptor

const file_media_delivery_tv_show_delivery_state_proto_rawDesc = "" +
	"\n" +
	"+media-delivery/tv-show-delivery-state.proto\x12\rmediadelivery\x1a\x1cgoogle/api/annotations.proto\x1a.protoc-gen-openapiv2/options/annotations.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1bgoogle/protobuf/empty.proto\x1a!media-delivery/common-model.proto\"\xde\x01\n" +
	"\x13TVShowDeliveryError\x12\x1b\n" +
	"\traw_error\x18\x01 \x01(\tR\brawError\x12K\n" +
	"\n" +
	"error_type\x18\x02 \x01(\x0e2,.mediadelivery.TVShowDeliveryError.ErrorTypeR\terrorType\"]\n" +
	"\tErrorType\x12\x1f\n" +
	"\x1bTVShowDeliveryError_Unknown\x10\x00\x12\x18\n" +
	"\x14TorrentSiteForbidden\x10\x01\x12\x15\n" +
	"\x11FilesAlreadyExist\x10\x02\"\x80\x02\n" +
	"\x13TVShowDeliveryState\x125\n" +
	"\x04data\x18\x01 \x01(\v2!.mediadelivery.TVShowDeliveryDataR\x04data\x125\n" +
	"\x04step\x18\x02 \x01(\x0e2!.mediadelivery.TVShowDeliveryStepR\x04step\x122\n" +
	"\x06status\x18\x03 \x01(\x0e2\x1a.mediadelivery.StateStatusR\x06status\x12=\n" +
	"\x05error\x18\x04 \x01(\v2\".mediadelivery.TVShowDeliveryErrorH\x00R\x05error\x88\x01\x01B\b\n" +
	"\x06_error\"\xb7\x02\n" +
	"\x05Track\x12#\n" +
	"\rrelative_path\x18\x01 \x01(\tR\frelativePath\x12\x1b\n" +
	"\tfull_path\x18\x02 \x01(\tR\bfullPath\x12\x17\n" +
	"\x04name\x18\x03 \x01(\tH\x00R\x04name\x88\x01\x01\x12\x1f\n" +
	"\blanguage\x18\x04 \x01(\tH\x01R\blanguage\x88\x01\x01\x122\n" +
	"\x04type\x18\x05 \x01(\x0e2\x1e.mediadelivery.Track.TrackTypeR\x04type\"h\n" +
	"\tTrackType\x12\x16\n" +
	"\x12TRACK_TYPE_UNKNOWN\x10\x00\x12\x14\n" +
	"\x10TRACK_TYPE_VIDEO\x10\x01\x12\x14\n" +
	"\x10TRACK_TYPE_AUDIO\x10\x02\x12\x17\n" +
	"\x13TRACK_TYPE_SUBTITLE\x10\x03B\a\n" +
	"\x05_nameB\v\n" +
	"\t_language\"#\n" +
	"\vSearchQuery\x12\x14\n" +
	"\x05Query\x18\x01 \x01(\tR\x05Query\"\xd6\x01\n" +
	"\rTorrentSearch\x12\x14\n" +
	"\x05title\x18\x01 \x01(\tR\x05title\x12\x12\n" +
	"\x04href\x18\x02 \x01(\tR\x04href\x12\x1a\n" +
	"\bcategory\x18\b \x01(\tR\bcategory\x12\x12\n" +
	"\x04size\x18\x03 \x01(\tR\x04size\x12\x14\n" +
	"\x05seeds\x18\x04 \x01(\x03R\x05seeds\x12\x18\n" +
	"\aleeches\x18\x05 \x01(\x03R\aleeches\x12\x1c\n" +
	"\tdownloads\x18\x06 \x01(\x03R\tdownloads\x12\x1d\n" +
	"\n" +
	"added_date\x18\a \x01(\tR\taddedDate\"\x9b\x01\n" +
	"\vEpisodeInfo\x12#\n" +
	"\rseason_number\x18\x01 \x01(\rR\fseasonNumber\x12%\n" +
	"\x0eepisode_number\x18\x02 \x01(\rR\repisodeNumber\x12\x1b\n" +
	"\tfull_path\x18\x03 \x01(\tR\bfullPath\x12#\n" +
	"\rrelative_path\x18\x04 \x01(\tR\frelativePath\"\xdd\x01\n" +
	"\fContentMatch\x124\n" +
	"\aepisode\x18\x01 \x01(\v2\x1a.mediadelivery.EpisodeInfoR\aepisode\x12*\n" +
	"\x05video\x18\x02 \x01(\v2\x14.mediadelivery.TrackR\x05video\x127\n" +
	"\faudio_tracks\x18\x03 \x03(\v2\x14.mediadelivery.TrackR\vaudioTracks\x122\n" +
	"\tsubtitles\x18\x04 \x03(\v2\x14.mediadelivery.TrackR\tsubtitles\"\xe5\x03\n" +
	"\x0eContentMatches\x125\n" +
	"\amatches\x18\x01 \x03(\v2\x1b.mediadelivery.ContentMatchR\amatches\x126\n" +
	"\vunallocated\x18\x02 \x03(\v2\x14.mediadelivery.TrackR\vunallocated\x12?\n" +
	"\aoptions\x18\x03 \x01(\v2%.mediadelivery.ContentMatches.OptionsR\aoptions\x1a\xa2\x02\n" +
	"\aOptions\x12.\n" +
	"\x13keep_original_audio\x18\x01 \x01(\bR\x11keepOriginalAudio\x126\n" +
	"\x17keep_original_subtitles\x18\x02 \x01(\bR\x15keepOriginalSubtitles\x12<\n" +
	"\x18default_audio_track_name\x18\x03 \x01(\tH\x00R\x15defaultAudioTrackName\x88\x01\x01\x129\n" +
	"\x16default_subtitle_track\x18\x04 \x01(\tH\x01R\x14defaultSubtitleTrack\x88\x01\x01B\x1b\n" +
	"\x19_default_audio_track_nameB\x19\n" +
	"\x17_default_subtitle_track\"\xd4\x01\n" +
	"\x1eChoseFileMatchesOptionsRequest\x127\n" +
	"\n" +
	"content_id\x18\x01 \x01(\v2\x18.mediadelivery.ContentIDR\tcontentId\x12\x18\n" +
	"\aapprove\x18\x02 \x01(\bR\aapprove\x12K\n" +
	"\x0fcontent_matches\x18\x03 \x01(\v2\x1d.mediadelivery.ContentMatchesH\x00R\x0econtentMatches\x88\x01\x01B\x12\n" +
	"\x10_content_matches\"\xd3\x02\n" +
	"\x15TorrentDownloadStatus\x12G\n" +
	"\x05state\x18\x01 \x01(\x0e21.mediadelivery.TorrentDownloadStatus.TorrentStateR\x05state\x12\x1a\n" +
	"\bprogress\x18\x02 \x01(\x02R\bprogress\x12\x1f\n" +
	"\vis_complete\x18\x03 \x01(\bR\n" +
	"isComplete\"\xb3\x01\n" +
	"\fTorrentState\x12\x19\n" +
	"\x15TORRENT_STATE_UNKNOWN\x10\x00\x12\x17\n" +
	"\x13TORRENT_STATE_ERROR\x10\x01\x12\x1b\n" +
	"\x17TORRENT_STATE_UPLOADING\x10\x02\x12\x1d\n" +
	"\x19TORRENT_STATE_DOWNLOADING\x10\x03\x12\x19\n" +
	"\x15TORRENT_STATE_STOPPED\x10\x04\x12\x18\n" +
	"\x14TORRENT_STATE_QUEUED\x10\x05\"O\n" +
	"\x10MergeVideoStatus\x12\x1a\n" +
	"\bprogress\x18\x01 \x01(\x02R\bprogress\x12\x1f\n" +
	"\vis_complete\x18\x02 \x01(\bR\n" +
	"isComplete\"V\n" +
	"\x11TVShowCatalogPath\x12 \n" +
	"\ftv_show_path\x18\x01 \x01(\tR\n" +
	"tvShowPath\x12\x1f\n" +
	"\vseason_path\x18\x02 \x01(\tR\n" +
	"seasonPath\"\xaa\x02\n" +
	"\rTVShowCatalog\x12!\n" +
	"\ftorrent_path\x18\x01 \x01(\tR\vtorrentPath\x12.\n" +
	"\x13torrent_size_pretty\x18\x02 \x01(\tR\x11torrentSizePretty\x12L\n" +
	"\x11media_server_path\x18\x03 \x01(\v2 .mediadelivery.TVShowCatalogPathR\x0fmediaServerPath\x127\n" +
	"\x18media_server_size_pretty\x18\x04 \x01(\tR\x15mediaServerSizePretty\x12?\n" +
	"\x1dis_copy_files_in_media_server\x18\x05 \x01(\bR\x18isCopyFilesInMediaServer\"\x1d\n" +
	"\aTorrent\x12\x12\n" +
	"\x04href\x18\x01 \x01(\tR\x04href\"\xa9\x05\n" +
	"\x12TVShowDeliveryData\x12B\n" +
	"\fsearch_query\x18\x01 \x01(\v2\x1a.mediadelivery.SearchQueryH\x00R\vsearchQuery\x88\x01\x01\x12C\n" +
	"\x0etorrent_search\x18\x02 \x03(\v2\x1c.mediadelivery.TorrentSearchR\rtorrentSearch\x12K\n" +
	"\x0fcontent_matches\x18\x03 \x01(\v2\x1d.mediadelivery.ContentMatchesH\x01R\x0econtentMatches\x88\x01\x01\x12a\n" +
	"\x17torrent_download_status\x18\x04 \x01(\v2$.mediadelivery.TorrentDownloadStatusH\x02R\x15torrentDownloadStatus\x88\x01\x01\x12R\n" +
	"\x12merge_video_status\x18\x05 \x01(\v2\x1f.mediadelivery.MergeVideoStatusH\x03R\x10mergeVideoStatus\x88\x01\x01\x12R\n" +
	"\x14tv_show_catalog_info\x18\x06 \x01(\v2\x1c.mediadelivery.TVShowCatalogH\x04R\x11tvShowCatalogInfo\x88\x01\x01\x125\n" +
	"\atorrent\x18\a \x01(\v2\x16.mediadelivery.TorrentH\x05R\atorrent\x88\x01\x01B\x0f\n" +
	"\r_search_queryB\x12\n" +
	"\x10_content_matchesB\x1a\n" +
	"\x18_torrent_download_statusB\x15\n" +
	"\x13_merge_video_statusB\x17\n" +
	"\x15_tv_show_catalog_infoB\n" +
	"\n" +
	"\b_torrent*\x8e\x04\n" +
	"\x12TVShowDeliveryStep\x12\x1d\n" +
	"\x19TVShowDeliveryStepUnknown\x10\x00\x12\x17\n" +
	"\x13GenerateSearchQuery\x10\x01\x12\x12\n" +
	"\x0eSearchTorrents\x10\x02\x12\x1b\n" +
	"\x17WaitingUserChoseTorrent\x10\x03\x12\x11\n" +
	"\rGetMagnetLink\x10\x04\x12\x1d\n" +
	"\x19AddTorrentToTorrentClient\x10\x05\x12\x16\n" +
	"\x12PrepareFileMatches\x10\x06\x12\x1b\n" +
	"\x17WaitingChoseFileMatches\x10\a\x12\"\n" +
	"\x1eWaitingTorrentDownloadComplete\x10\b\x12\x1e\n" +
	"\x1aCreateVideoContentCatalogs\x10\t\x12\x1f\n" +
	"\x1bDeterminingNeedConvertFiles\x10\n" +
	"\x12\x18\n" +
	"\x14StartMergeVideoFiles\x10\v\x12\x1a\n" +
	"\x16WaitingMergeVideoFiles\x10\f\x12\x16\n" +
	"\x12CreateHardLinkCopy\x10\r\x12\x13\n" +
	"\x0fGetCatalogsSize\x10\x0f\x12\x14\n" +
	"\x10SetMediaMetaData\x10\x10\x12\x1c\n" +
	"\x18SendDeliveryNotification\x10\x11\x12\x17\n" +
	"\x13WaitingTorrentFiles\x10\x12\x12\x13\n" +
	"\x0fGetEpisodesData\x10\x13B'Z%github.com/kkiling/media-delivery/apib\x06proto3"

var (
	file_media_delivery_tv_show_delivery_state_proto_rawDescOnce sync.Once
	file_media_delivery_tv_show_delivery_state_proto_rawDescData []byte
)

func file_media_delivery_tv_show_delivery_state_proto_rawDescGZIP() []byte {
	file_media_delivery_tv_show_delivery_state_proto_rawDescOnce.Do(func() {
		file_media_delivery_tv_show_delivery_state_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_media_delivery_tv_show_delivery_state_proto_rawDesc), len(file_media_delivery_tv_show_delivery_state_proto_rawDesc)))
	})
	return file_media_delivery_tv_show_delivery_state_proto_rawDescData
}

var file_media_delivery_tv_show_delivery_state_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_media_delivery_tv_show_delivery_state_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_media_delivery_tv_show_delivery_state_proto_goTypes = []any{
	(TVShowDeliveryStep)(0),                 // 0: mediadelivery.TVShowDeliveryStep
	(TVShowDeliveryError_ErrorType)(0),      // 1: mediadelivery.TVShowDeliveryError.ErrorType
	(Track_TrackType)(0),                    // 2: mediadelivery.Track.TrackType
	(TorrentDownloadStatus_TorrentState)(0), // 3: mediadelivery.TorrentDownloadStatus.TorrentState
	(*TVShowDeliveryError)(nil),             // 4: mediadelivery.TVShowDeliveryError
	(*TVShowDeliveryState)(nil),             // 5: mediadelivery.TVShowDeliveryState
	(*Track)(nil),                           // 6: mediadelivery.Track
	(*SearchQuery)(nil),                     // 7: mediadelivery.SearchQuery
	(*TorrentSearch)(nil),                   // 8: mediadelivery.TorrentSearch
	(*EpisodeInfo)(nil),                     // 9: mediadelivery.EpisodeInfo
	(*ContentMatch)(nil),                    // 10: mediadelivery.ContentMatch
	(*ContentMatches)(nil),                  // 11: mediadelivery.ContentMatches
	(*ChoseFileMatchesOptionsRequest)(nil),  // 12: mediadelivery.ChoseFileMatchesOptionsRequest
	(*TorrentDownloadStatus)(nil),           // 13: mediadelivery.TorrentDownloadStatus
	(*MergeVideoStatus)(nil),                // 14: mediadelivery.MergeVideoStatus
	(*TVShowCatalogPath)(nil),               // 15: mediadelivery.TVShowCatalogPath
	(*TVShowCatalog)(nil),                   // 16: mediadelivery.TVShowCatalog
	(*Torrent)(nil),                         // 17: mediadelivery.Torrent
	(*TVShowDeliveryData)(nil),              // 18: mediadelivery.TVShowDeliveryData
	(*ContentMatches_Options)(nil),          // 19: mediadelivery.ContentMatches.Options
	(StateStatus)(0),                        // 20: mediadelivery.StateStatus
	(*ContentID)(nil),                       // 21: mediadelivery.ContentID
}
var file_media_delivery_tv_show_delivery_state_proto_depIdxs = []int32{
	1,  // 0: mediadelivery.TVShowDeliveryError.error_type:type_name -> mediadelivery.TVShowDeliveryError.ErrorType
	18, // 1: mediadelivery.TVShowDeliveryState.data:type_name -> mediadelivery.TVShowDeliveryData
	0,  // 2: mediadelivery.TVShowDeliveryState.step:type_name -> mediadelivery.TVShowDeliveryStep
	20, // 3: mediadelivery.TVShowDeliveryState.status:type_name -> mediadelivery.StateStatus
	4,  // 4: mediadelivery.TVShowDeliveryState.error:type_name -> mediadelivery.TVShowDeliveryError
	2,  // 5: mediadelivery.Track.type:type_name -> mediadelivery.Track.TrackType
	9,  // 6: mediadelivery.ContentMatch.episode:type_name -> mediadelivery.EpisodeInfo
	6,  // 7: mediadelivery.ContentMatch.video:type_name -> mediadelivery.Track
	6,  // 8: mediadelivery.ContentMatch.audio_tracks:type_name -> mediadelivery.Track
	6,  // 9: mediadelivery.ContentMatch.subtitles:type_name -> mediadelivery.Track
	10, // 10: mediadelivery.ContentMatches.matches:type_name -> mediadelivery.ContentMatch
	6,  // 11: mediadelivery.ContentMatches.unallocated:type_name -> mediadelivery.Track
	19, // 12: mediadelivery.ContentMatches.options:type_name -> mediadelivery.ContentMatches.Options
	21, // 13: mediadelivery.ChoseFileMatchesOptionsRequest.content_id:type_name -> mediadelivery.ContentID
	11, // 14: mediadelivery.ChoseFileMatchesOptionsRequest.content_matches:type_name -> mediadelivery.ContentMatches
	3,  // 15: mediadelivery.TorrentDownloadStatus.state:type_name -> mediadelivery.TorrentDownloadStatus.TorrentState
	15, // 16: mediadelivery.TVShowCatalog.media_server_path:type_name -> mediadelivery.TVShowCatalogPath
	7,  // 17: mediadelivery.TVShowDeliveryData.search_query:type_name -> mediadelivery.SearchQuery
	8,  // 18: mediadelivery.TVShowDeliveryData.torrent_search:type_name -> mediadelivery.TorrentSearch
	11, // 19: mediadelivery.TVShowDeliveryData.content_matches:type_name -> mediadelivery.ContentMatches
	13, // 20: mediadelivery.TVShowDeliveryData.torrent_download_status:type_name -> mediadelivery.TorrentDownloadStatus
	14, // 21: mediadelivery.TVShowDeliveryData.merge_video_status:type_name -> mediadelivery.MergeVideoStatus
	16, // 22: mediadelivery.TVShowDeliveryData.tv_show_catalog_info:type_name -> mediadelivery.TVShowCatalog
	17, // 23: mediadelivery.TVShowDeliveryData.torrent:type_name -> mediadelivery.Torrent
	24, // [24:24] is the sub-list for method output_type
	24, // [24:24] is the sub-list for method input_type
	24, // [24:24] is the sub-list for extension type_name
	24, // [24:24] is the sub-list for extension extendee
	0,  // [0:24] is the sub-list for field type_name
}

func init() { file_media_delivery_tv_show_delivery_state_proto_init() }
func file_media_delivery_tv_show_delivery_state_proto_init() {
	if File_media_delivery_tv_show_delivery_state_proto != nil {
		return
	}
	file_media_delivery_common_model_proto_init()
	file_media_delivery_tv_show_delivery_state_proto_msgTypes[1].OneofWrappers = []any{}
	file_media_delivery_tv_show_delivery_state_proto_msgTypes[2].OneofWrappers = []any{}
	file_media_delivery_tv_show_delivery_state_proto_msgTypes[8].OneofWrappers = []any{}
	file_media_delivery_tv_show_delivery_state_proto_msgTypes[14].OneofWrappers = []any{}
	file_media_delivery_tv_show_delivery_state_proto_msgTypes[15].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_media_delivery_tv_show_delivery_state_proto_rawDesc), len(file_media_delivery_tv_show_delivery_state_proto_rawDesc)),
			NumEnums:      4,
			NumMessages:   16,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_media_delivery_tv_show_delivery_state_proto_goTypes,
		DependencyIndexes: file_media_delivery_tv_show_delivery_state_proto_depIdxs,
		EnumInfos:         file_media_delivery_tv_show_delivery_state_proto_enumTypes,
		MessageInfos:      file_media_delivery_tv_show_delivery_state_proto_msgTypes,
	}.Build()
	File_media_delivery_tv_show_delivery_state_proto = out.File
	file_media_delivery_tv_show_delivery_state_proto_goTypes = nil
	file_media_delivery_tv_show_delivery_state_proto_depIdxs = nil
}
